/**
 * StudentTimetablePanel.tsx - 학생 시간표 패널 컴포넌트 (검은색/하얀색 테마)
 *
 * Phase 2 구현:
 * - 학생 시간표 표시
 * - 시간표 그리드 렌더링
 * - 시간표 생성/수정 기능
 */

import React, { useState } from 'react';
import { StudentWithTimetable, StudentTimetableData, TimeSlot, TimeSlotType } from '../../../types/student';
import { studentTimetableService } from '../../../services/backendService';
import TimeSlotEditModal from './TimeSlotEditModal';
import ShareLinkModal from './ShareLinkModal';
import EditLinkManagementModal from './EditLinkManagementModal';
import './StudentTimetablePanel.css';

interface StudentTimetablePanelProps {
  student: StudentWithTimetable;
  timetable: StudentTimetableData | null;
  onTimetableUpdate: (timetable: StudentTimetableData) => void;
  onTimetableCreate: () => void;
}

const StudentTimetablePanel: React.FC<StudentTimetablePanelProps> = ({
  student,
  timetable,
  onTimetableUpdate,
  onTimetableCreate
}) => {
  // 시간표 편집 모달 상태
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  // 공유 링크 모달 상태
  const [isShareLinkModalOpen, setIsShareLinkModalOpen] = useState(false);
  // 편집 링크 관리 모달 상태
  const [isEditLinkManagementModalOpen, setIsEditLinkManagementModalOpen] = useState(false);

  // 시간표 편집 모달 열기
  const handleEditTimetable = () => {
    setIsEditModalOpen(true);
  };

  // 모달 닫기
  const closeEditModal = () => {
    setIsEditModalOpen(false);
  };

  // 공유 링크 생성 핸들러
  const handleCreateShareLink = () => {
    setIsShareLinkModalOpen(true);
  };

  // 공유 링크 모달 닫기
  const closeShareLinkModal = () => {
    setIsShareLinkModalOpen(false);
  };

  // 편집 링크 관리 모달 열기
  const handleEditLinkManagement = () => {
    setIsEditLinkManagementModalOpen(true);
  };

  // 편집 링크 관리 모달 닫기
  const closeEditLinkManagementModal = () => {
    setIsEditLinkManagementModalOpen(false);
  };

  // 수업 추가 핸들러
  const handleAddClass = async (classData: {
    day: string;
    startTime: string;
    endTime: string;
    subject: string;
    teacher?: string;
    location?: string;
    type: TimeSlotType;
    color: string;
    notes?: string;
  }) => {
    if (!timetable) return;

    try {
      // 새 시간표 데이터 생성
      const newTimetable = { ...timetable };
      const daySchedule = newTimetable.detailedSchedule[classData.day];
      
      // 요일 스케줄이 존재하지 않는 경우 초기화
      if (!daySchedule) {
        newTimetable.detailedSchedule[classData.day] = { timeSlots: [] };
      }
      
      // 새 수업 추가
      const newSlot: TimeSlot = {
        id: Date.now().toString(),
        startTime: classData.startTime,
        endTime: classData.endTime,
        subject: classData.subject,
        teacher: classData.teacher || undefined,
        location: classData.location || undefined,
        type: classData.type,
        color: classData.color,
        notes: classData.notes || undefined,
        isAutoGenerated: false
      };

      newTimetable.detailedSchedule[classData.day].timeSlots.push(newSlot);
      newTimetable.detailedSchedule[classData.day].timeSlots.sort((a, b) => a.startTime.localeCompare(b.startTime));

      // 백엔드에 저장
      await studentTimetableService.updateStudentTimetable(timetable.id, {
        detailedSchedule: newTimetable.detailedSchedule
      });

      // 시간표 업데이트
      onTimetableUpdate(newTimetable);
    } catch (error) {
      console.error('수업 추가 실패:', error);
      throw error;
    }
  };

  // 수업 삭제 핸들러
  const handleDeleteClass = async (day: string, slotId: string) => {
    if (!timetable) return;

    try {
      const newTimetable = { ...timetable };
      const daySchedule = newTimetable.detailedSchedule[day];
      
      // 요일 스케줄이 존재하지 않는 경우 처리
      if (!daySchedule) {
        throw new Error('해당 요일의 스케줄을 찾을 수 없습니다.');
      }
      
      daySchedule.timeSlots = daySchedule.timeSlots.filter(slot => slot.id !== slotId);

      // 백엔드에 저장
      await studentTimetableService.updateStudentTimetable(timetable.id, {
        detailedSchedule: newTimetable.detailedSchedule
      });

      // 시간표 업데이트
      onTimetableUpdate(newTimetable);
    } catch (error) {
      console.error('수업 삭제 실패:', error);
      throw error;
    }
  };
  // 시간대 생성 함수 (9시부터 24시까지, 30분 간격)
  const generateTimeSlots = () => {
    const slots = [];
    const startHour = 9; // 9시부터 시작
    const endHour = 24;  // 24시까지
    const interval = 30; // 30분 간격
    
    for (let hour = startHour; hour < endHour; hour++) {
      for (let min = 0; min < 60; min += interval) {
        const timeString = `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
        const minutes = hour * 60 + min;
        const nextMinutes = minutes + interval;
        
        slots.push({
          time: timeString,
          startMinutes: minutes,
          endMinutes: nextMinutes
        });
      }
    }
    
    return slots;
  };

  // 특정 요일의 수업들을 시간대별로 매핑하는 함수 (자동 자습 채우기 포함)
  const getTimeSlotMapping = (day: string) => {
    const daySchedule = timetable?.detailedSchedule[day];
    const timeSlots = generateTimeSlots();
    const mapping: { [key: string]: any } = {};
    const occupiedSlots = new Set<number>(); // 수업이 차지하는 모든 슬롯 추적

    // 실제 수업들을 매핑
    if (daySchedule) {
      daySchedule.timeSlots.forEach(slot => {
        const slotStartMinutes = timeToMinutes(slot.startTime);
        const slotEndMinutes = timeToMinutes(slot.endTime);
        
        // 이 수업이 시작되는 첫 번째 시간 슬롯 찾기
        const startSlotIndex = timeSlots.findIndex(ts => 
          ts.startMinutes <= slotStartMinutes && ts.endMinutes > slotStartMinutes
        );
        
        if (startSlotIndex !== -1) {
          // 이 수업이 몇 개의 시간 슬롯을 차지하는지 계산 (세로로)
          const spanCount = Math.ceil((slotEndMinutes - slotStartMinutes) / 30); // 고정 30분 간격
          
          // 수업이 차지하는 모든 슬롯을 occupiedSlots에 추가
          for (let i = 0; i < spanCount; i++) {
            occupiedSlots.add(startSlotIndex + i);
          }
          
          mapping[startSlotIndex] = {
            ...slot,
            spanCount: Math.max(1, spanCount)
          };
        }
      });
    }

    // 등원시간 범위 내에서만 자습 채우기 (요일별, 활성화된 요일만)
    const basicDaySchedule = timetable?.basicSchedule?.dailySchedules?.[day as keyof typeof timetable.basicSchedule.dailySchedules];

    // isActive가 true인 요일만 자습 채우기
    if (basicDaySchedule?.isActive) {
      const arrivalMinutes = timeToMinutes(basicDaySchedule.arrivalTime);
      const departureMinutes = timeToMinutes(basicDaySchedule.departureTime);

      // 빈 슬롯을 자습으로 자동 채우기 (등원시간 범위 내에서만)
      timeSlots.forEach((timeSlot, index) => {
        // 등원시간 범위 내이고, 수업이 차지하지 않는 슬롯만 자습으로 채우기
        if (timeSlot.startMinutes >= arrivalMinutes &&
            timeSlot.startMinutes < departureMinutes &&
            !occupiedSlots.has(index)) {

          mapping[index] = {
            id: `self-study-${day}-${index}`,
            startTime: timeSlot.time,
            endTime: timeSlots[index + 1]?.time || '24:00',
            subject: '자습',
            type: 'self_study',
            color: '#9E9E9E',
            isAutoGenerated: true,
            spanCount: 1
          };
        }
      });
    }

    return mapping;
  };

  // 시간을 분으로 변환하는 함수
  const timeToMinutes = (time: string): number => {
    const [hours, minutes] = time.split(':').map(Number);
    return hours * 60 + minutes;
  };

  // 요일 배열
  const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
  const dayNames = ['월', '화', '수', '목', '금', '토', '일'];

  // 시간표가 없는 경우
  if (!timetable) {
    return (
      <div className="stp-main-panel">
        <div className="stp-panel-header">
          <div className="stp-student-info">
            <h2>{student.name}</h2>
            <p className="stp-student-details">{student.grade}</p>
          </div>
          <div className="stp-header-actions">
            <button
              className="stp-btn-create"
              onClick={onTimetableCreate}
            >
              + 시간표 생성
            </button>
          </div>
        </div>
        <div className="stp-empty-state">
          <h3>시간표가 없습니다</h3>
          <p>새로운 시간표를 생성해보세요.</p>
        </div>
      </div>
    );
  }

  const timeSlots = generateTimeSlots();

  return (
    <div className="stp-main-panel">
      {/* 헤더 */}
      <div className="stp-panel-header">
        <div className="stp-student-info">
          <h2>{student.name}</h2>
          <p className="stp-student-details">
            {student.grade} • {timetable.name}
          </p>
        </div>
        <div className="stp-header-actions">
          <button
            className="stp-btn-share-link"
            onClick={handleCreateShareLink}
            title="학생 편집 링크 생성"
          >
            🔗 편집 링크
          </button>
          <button
            className="stp-btn-edit-link-management"
            onClick={handleEditLinkManagement}
            title="편집 링크 관리"
          >
            ⚙️ 링크 관리
          </button>
          <button
            className="stp-btn-edit-timetable"
            onClick={handleEditTimetable}
            title="시간표 편집"
          >
            ✏️ 시간표 편집
          </button>
          <button
            className="stp-btn-refresh"
            onClick={() => window.location.reload()}
            title="새로고침"
          >
            🔄
          </button>
        </div>
      </div>

      {/* 시간표 그리드 */}
      <div className="stp-timetable-container">
        <table className="stp-timetable-grid">
          <thead>
            <tr>
              <th className="stp-time-header">시간</th>
              {daysOfWeek.map((day, index) => (
                <th key={day} className="stp-day-header">
                  {dayNames[index]}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {timeSlots.map((slot, slotIndex) => (
              <tr key={slotIndex}>
                <td className="stp-time-header">
                  {slot.time}
                </td>
                {daysOfWeek.map((day) => {
                  const timeSlotMapping = getTimeSlotMapping(day);
                  const timeSlot = timeSlotMapping[slotIndex];
                  
                  // 이 셀이 수업의 시작점인지 확인
                  if (timeSlot) {
                    console.log('TimeSlot color:', timeSlot.color, 'for subject:', timeSlot.subject);
                    return (
                      <td 
                        key={day} 
                        className="stp-time-slot stp-slot-with-content"
                        rowSpan={timeSlot.spanCount}
                        style={{ 
                          backgroundColor: timeSlot.color || '#f0f0f0',
                          borderColor: timeSlot.color || '#2196f3'
                        }}
                      >
                        <div className="stp-slot-content">
                          {timeSlot.type !== 'self_study' && (
                            <div className="stp-slot-subject">{timeSlot.subject}</div>
                          )}
                          <div className="stp-slot-time">
                            {timeSlot.startTime} - {timeSlot.endTime}
                          </div>
                          <div className={`stp-slot-type ${timeSlot.type === 'external' ? 'external-class' : timeSlot.type}`}>
                            {timeSlot.type === 'class' ? '수업' : 
                             timeSlot.type === 'self_study' ? '자습' : '외부수업'}
                          </div>
                        </div>
                      </td>
                    );
                  }
                  
                  // 이 셀이 다른 수업에 의해 이미 차지되었는지 확인
                  const isOccupied = Object.keys(timeSlotMapping).some(startIndex => {
                    const slot = timeSlotMapping[startIndex];
                    const startIdx = parseInt(startIndex);
                    return slotIndex > startIdx && slotIndex < startIdx + slot.spanCount;
                  });
                  
                  if (isOccupied) {
                    return null; // 이미 다른 수업이 차지한 셀이므로 렌더링하지 않음
                  }
                  
                  // 빈 셀
                  return (
                    <td key={day} className="stp-time-slot">
                      <div className="stp-slot-content">
                        <div className="stp-slot-subject">-</div>
                      </div>
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {/* TimeSlotEditModal */}
      {isEditModalOpen && timetable && (
        <TimeSlotEditModal
          isOpen={isEditModalOpen}
          onClose={closeEditModal}
          onAddClass={handleAddClass}
          onDeleteClass={handleDeleteClass}
          timetable={timetable}
        />
      )}

      {/* ShareLinkModal */}
      {isShareLinkModalOpen && timetable && (
        <ShareLinkModal
          isOpen={isShareLinkModalOpen}
          onClose={closeShareLinkModal}
          student={student}
          timetable={timetable}
        />
      )}

      {/* EditLinkManagementModal */}
      <EditLinkManagementModal
        isOpen={isEditLinkManagementModalOpen}
        onClose={closeEditLinkManagementModal}
        studentId={student.id}
        studentName={student.name}
      />
    </div>
  );
};

export default StudentTimetablePanel;