import * as functions from "firebase-functions";
import * as admin from "firebase-admin";

type DayOfWeek = "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";

interface TimeSlot {
  startTime: string;
  endTime: string;
  subject: string;
  type: "class" | "self_study";
  isAutoGenerated: boolean;
  color?: string;
}

interface Timetable {
  name: string;
  basicSchedule: {
    arrivalTime: string;
    departureTime: string;
    daysOfWeek: DayOfWeek[];
    timeSlotInterval: number;
  };
  detailedSchedule: {
    [dayOfWeek: string]: {
      timeSlots: TimeSlot[];
    };
  };
  isShared: boolean;
  shareToken?: string;
  shareSettings: {
    allowEdit: boolean;
    allowView: boolean;
    expiresAt?: admin.firestore.Timestamp;
  };
  autoFillSettings: {
    enabled: boolean;
    defaultSubject: string;
    fillEmptySlots: boolean;
  };
  isActive: boolean;
  createdAt: admin.firestore.Timestamp;
  updatedAt: admin.firestore.Timestamp;
}

/**
 * 시간표 생성
 */
export const createTimetable = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const {
    name,
    arrivalTime,
    departureTime,
    daysOfWeek,
    timeSlotInterval = 30,
    autoFillEnabled = true
  } = data;

  if (!name || !arrivalTime || !departureTime || !daysOfWeek) {
    throw new functions.https.HttpsError("invalid-argument", "필수 필드가 누락되었습니다.");
  }

  try {
    const db = admin.firestore();
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("timetables")
      .doc();

    const timetableData: Timetable = {
      name,
      basicSchedule: {
        arrivalTime,
        departureTime,
        daysOfWeek,
        timeSlotInterval
      },
      detailedSchedule: {},
      isShared: false,
      shareSettings: {
        allowEdit: false,
        allowView: false
      },
      autoFillSettings: {
        enabled: autoFillEnabled,
        defaultSubject: "자습",
        fillEmptySlots: true
      },
      isActive: true,
      createdAt: admin.firestore.Timestamp.now(),
      updatedAt: admin.firestore.Timestamp.now()
    };

    // 기본 시간표 틀 생성 (자동 자습시간 채우기)
    if (autoFillEnabled) {
      timetableData.detailedSchedule = generateAutoFilledSchedule(
        arrivalTime,
        departureTime,
        daysOfWeek,
        timeSlotInterval
      );
    }

    await timetableRef.set(timetableData);

    return {
      success: true,
      message: "시간표가 생성되었습니다.",
      data: { timetableId: timetableRef.id }
    };
  } catch (error) {
    console.error("시간표 생성 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 시간표 조회
 */
export const getTimetables = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { timetableId, activeOnly = true } = data;

  try {
    const db = admin.firestore();

    if (timetableId) {
      // 특정 시간표 조회
      const timetableDoc = await db
        .collection("users")
        .doc(userId)
        .collection("timetables")
        .doc(timetableId)
        .get();

      if (!timetableDoc.exists) {
        throw new functions.https.HttpsError("not-found", "시간표를 찾을 수 없습니다.");
      }

      return {
        success: true,
        data: { id: timetableDoc.id, ...timetableDoc.data() }
      };
    } else {
      // 전체 시간표 목록 조회
      let query = db
        .collection("users")
        .doc(userId)
        .collection("timetables")
        .orderBy("createdAt", "desc");

      if (activeOnly) {
        query = query.where("isActive", "==", true);
      }

      const snapshot = await query.get();
      const timetables = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));

      return {
        success: true,
        data: timetables
      };
    }
  } catch (error) {
    console.error("시간표 조회 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 시간표 상세 일정 업데이트
 */
export const updateTimetableSchedule = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { timetableId, dayOfWeek, timeSlots } = data;

  if (!timetableId || !dayOfWeek || !timeSlots) {
    throw new functions.https.HttpsError("invalid-argument", "필수 필드가 누락되었습니다.");
  }

  try {
    const db = admin.firestore();
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("timetables")
      .doc(timetableId);

    const timetableDoc = await timetableRef.get();
    if (!timetableDoc.exists) {
      throw new functions.https.HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    const updateData = {
      [`detailedSchedule.${dayOfWeek}.timeSlots`]: timeSlots,
      updatedAt: admin.firestore.Timestamp.now()
    };

    await timetableRef.update(updateData);

    return {
      success: true,
      message: "시간표가 업데이트되었습니다."
    };
  } catch (error) {
    console.error("시간표 업데이트 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 자동 자습시간 채우기
 */
export const autoFillSelfStudy = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { timetableId, dayOfWeek } = data;

  if (!timetableId) {
    throw new functions.https.HttpsError("invalid-argument", "timetableId가 필요합니다.");
  }

  try {
    const db = admin.firestore();
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("timetables")
      .doc(timetableId);

    const timetableDoc = await timetableRef.get();
    if (!timetableDoc.exists) {
      throw new functions.https.HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    const timetableData = timetableDoc.data() as Timetable;
    const { basicSchedule, autoFillSettings } = timetableData;

    if (!autoFillSettings.enabled) {
      throw new functions.https.HttpsError("failed-precondition", "자동 채우기가 비활성화되어 있습니다.");
    }

    const targetDays = dayOfWeek ? [dayOfWeek] : basicSchedule.daysOfWeek;
    const updatedSchedule = { ...timetableData.detailedSchedule };

    for (const day of targetDays) {
      const filledTimeSlots = fillEmptyTimeSlots(
        basicSchedule.arrivalTime,
        basicSchedule.departureTime,
        basicSchedule.timeSlotInterval,
        updatedSchedule[day]?.timeSlots || [],
        autoFillSettings.defaultSubject
      );

      updatedSchedule[day] = { timeSlots: filledTimeSlots };
    }

    await timetableRef.update({
      detailedSchedule: updatedSchedule,
      updatedAt: admin.firestore.Timestamp.now()
    });

    return {
      success: true,
      message: "자동 자습시간 채우기가 완료되었습니다.",
      data: { updatedDays: targetDays }
    };
  } catch (error) {
    console.error("자동 자습시간 채우기 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 시간표 삭제
 */
export const deleteTimetable = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { timetableId } = data;

  if (!timetableId) {
    throw new functions.https.HttpsError("invalid-argument", "timetableId가 필요합니다.");
  }

  try {
    const db = admin.firestore();
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("timetables")
      .doc(timetableId);

    // 소프트 삭제 (isActive = false)
    await timetableRef.update({
      isActive: false,
      updatedAt: admin.firestore.Timestamp.now()
    });

    return {
      success: true,
      message: "시간표가 삭제되었습니다."
    };
  } catch (error) {
    console.error("시간표 삭제 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

// ===== 유틸리티 함수들 =====

/**
 * 자동으로 채워진 시간표 생성
 */
function generateAutoFilledSchedule(
  arrivalTime: string,
  departureTime: string,
  daysOfWeek: DayOfWeek[],
  timeSlotInterval: number
): { [dayOfWeek: string]: { timeSlots: TimeSlot[] } } {
  const schedule: { [dayOfWeek: string]: { timeSlots: TimeSlot[] } } = {};

  for (const day of daysOfWeek) {
    const timeSlots = fillEmptyTimeSlots(
      arrivalTime,
      departureTime,
      timeSlotInterval,
      [],
      "자습"
    );
    schedule[day] = { timeSlots };
  }

  return schedule;
}

/**
 * 빈 시간대를 자습으로 채우기
 */
function fillEmptyTimeSlots(
  startTime: string,
  endTime: string,
  interval: number,
  existingSlots: TimeSlot[],
  defaultSubject: string
): TimeSlot[] {
  const slots: TimeSlot[] = [...existingSlots];

  // 시간을 분 단위로 변환
  const startMinutes = timeToMinutes(startTime);
  const endMinutes = timeToMinutes(endTime);

  // 기존 슬롯들이 차지하는 시간대 확인
  const occupiedTimes = existingSlots.map(slot => ({
    start: timeToMinutes(slot.startTime),
    end: timeToMinutes(slot.endTime)
  })).sort((a, b) => a.start - b.start);

  let currentTime = startMinutes;

  for (const occupied of occupiedTimes) {
    // 현재 시간과 다음 점유 시간 사이에 빈 공간이 있으면 자습으로 채움
    if (currentTime < occupied.start) {
      while (currentTime < occupied.start && currentTime + interval <= endMinutes) {
        slots.push({
          startTime: minutesToTime(currentTime),
          endTime: minutesToTime(currentTime + interval),
          subject: defaultSubject,
          type: "self_study",
          isAutoGenerated: true
        });
        currentTime += interval;
      }
    }
    currentTime = Math.max(currentTime, occupied.end);
  }

  // 마지막 점유 시간 이후 남은 시간을 자습으로 채움
  while (currentTime + interval <= endMinutes) {
    slots.push({
      startTime: minutesToTime(currentTime),
      endTime: minutesToTime(currentTime + interval),
      subject: defaultSubject,
      type: "self_study",
      isAutoGenerated: true
    });
    currentTime += interval;
  }

  return slots.sort((a, b) => timeToMinutes(a.startTime) - timeToMinutes(b.startTime));
}

/**
 * 시간 문자열을 분 단위로 변환 (HH:mm -> 분)
 */
function timeToMinutes(time: string): number {
  const [hours, minutes] = time.split(":").map(Number);
  return hours * 60 + minutes;
}

/**
 * 분을 시간 문자열로 변환 (분 -> HH:mm)
 */
function minutesToTime(minutes: number): string {
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  return `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}`;
}
