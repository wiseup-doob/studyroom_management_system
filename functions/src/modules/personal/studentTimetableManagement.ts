/**
 * 학생별 시간표 관리 Cloud Functions
 * DATABASE_DESIGN.md의 고급 시간표 구조 완벽 지원
 *
 * 사용자 기반 데이터 격리 아키텍처:
 * - 각 사용자는 자신의 학생 시간표 데이터에만 접근 가능
 * - Google 인증 기반 권한 관리
 * - 완전한 데이터 격리
 */

import { onCall, HttpsError } from "firebase-functions/v2/https";
import { getFirestore, FieldValue } from "firebase-admin/firestore";
import { logger } from "firebase-functions";
import { parseTimeToMinutes, minutesToTime } from "../../utils/timeUtils";

const db = getFirestore();

// CORS 설정: 현재 프로젝트의 도메인 허용
const projectId = process.env.GCLOUD_PROJECT || (process.env.FIREBASE_CONFIG ? JSON.parse(process.env.FIREBASE_CONFIG).projectId : "");
const corsConfig = projectId ? [
  `https://${projectId}.web.app`,
  `https://${projectId}.firebaseapp.com`
] : true;

// 타입 정의
export type DayOfWeek = "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";

export interface TimeSlot {
  startTime: string;
  endTime: string;
  subject: string;
  type: "class" | "self_study" | "external";
  isAutoGenerated: boolean;
  color?: string;
  teacher?: string;
  location?: string;
  notes?: string;
}

export interface BasicSchedule {
  dailySchedules: {
    [key in DayOfWeek]: {
      arrivalTime: string;
      departureTime: string;
      isActive: boolean;
    };
  };
  timeSlotInterval: number;
}

export interface AutoFillSettings {
  enabled: boolean;
  defaultSubject: string;
  fillEmptySlots: boolean;
}


export interface StudentTimetableData {
  id: string;
  studentId: string;
  studentName: string;
  name: string;
  description?: string;

  // 1차 레이어: 등원/하원 기본 틀
  basicSchedule: BasicSchedule;

  // 2차 레이어: 구체적인 일정
  detailedSchedule: {
    [dayOfWeek: string]: {
      timeSlots: TimeSlot[];
    };
  };


  // 자동 채우기 설정
  autoFillSettings: AutoFillSettings;

  isActive: boolean;
  isDefault: boolean;
  createdAt: FirebaseFirestore.Timestamp;
  updatedAt: FirebaseFirestore.Timestamp;
  userId: string;
}

// 요청 인터페이스
export interface CreateStudentTimetableRequest {
  studentId: string;
  name: string;
  description?: string;
  basicSchedule: BasicSchedule;
  autoFillSettings?: Partial<AutoFillSettings>;
}

export interface UpdateStudentTimetableRequest {
  name?: string;
  description?: string;
  basicSchedule?: BasicSchedule;
  detailedSchedule?: any;
  autoFillSettings?: AutoFillSettings;
}


/**
 * 데이터 검증 함수
 */
function validateBasicSchedule(basicSchedule: BasicSchedule): void {
  if (!basicSchedule.dailySchedules) {
    throw new HttpsError("invalid-argument", "요일별 스케줄 정보가 필요합니다.");
  }

  // 활성화된 요일이 있는지 확인
  const activeDays = Object.values(basicSchedule.dailySchedules).filter(day => day.isActive);
  if (activeDays.length === 0) {
    throw new HttpsError("invalid-argument", "최소 하나의 요일을 선택해주세요.");
  }

  // 각 활성 요일의 시간 유효성 검사
  for (const [day, schedule] of Object.entries(basicSchedule.dailySchedules)) {
    if (schedule.isActive) {
      if (!schedule.arrivalTime || !schedule.departureTime) {
        throw new HttpsError("invalid-argument", `${day}의 등원 시간과 하원 시간은 필수입니다.`);
      }
      
      if (schedule.arrivalTime >= schedule.departureTime) {
        throw new HttpsError("invalid-argument", `${day}의 하원 시간은 등원 시간보다 늦어야 합니다.`);
      }
    }
  }

  if (!basicSchedule.timeSlotInterval || basicSchedule.timeSlotInterval < 15) {
    throw new HttpsError("invalid-argument", "시간 간격은 최소 15분 이상이어야 합니다.");
  }
}


/**
 * 유틸리티 함수들
 *
 * Note: parseTime, minutesToTime 함수는 utils/timeUtils.ts에서 import하여 사용
 * (함수 중복 제거)
 */


/**
 * 학생별 시간표 생성
 */
export const createStudentTimetable = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
    }

    const userId = auth.uid;
    const timetableRequest = data as CreateStudentTimetableRequest;

    // 데이터 검증
    if (!timetableRequest.studentId || !timetableRequest.name) {
      throw new HttpsError("invalid-argument", "학생 ID와 시간표 이름은 필수입니다.");
    }

    validateBasicSchedule(timetableRequest.basicSchedule);

    // 학생 존재 확인
    const studentDoc = await db
      .collection("users")
      .doc(userId)
      .collection("students")
      .doc(timetableRequest.studentId)
      .get();

    if (!studentDoc.exists) {
      throw new HttpsError("not-found", "학생을 찾을 수 없습니다.");
    }

    const studentData = studentDoc.data();
    if (!studentData || !studentData.isActive) {
      throw new HttpsError("not-found", "활성 상태인 학생을 찾을 수 없습니다.");
    }

    // 새 시간표 데이터 생성
    const timetableData: Omit<StudentTimetableData, "id"> = {
      studentId: timetableRequest.studentId,
      studentName: studentData.name,
      name: timetableRequest.name.trim(),
      description: timetableRequest.description?.trim(),
      basicSchedule: timetableRequest.basicSchedule,
      detailedSchedule: {},
      autoFillSettings: {
        enabled: true,
        defaultSubject: "자습",
        fillEmptySlots: true,
        ...timetableRequest.autoFillSettings
      },
      isActive: true,
      isDefault: false,
      createdAt: FieldValue.serverTimestamp() as FirebaseFirestore.Timestamp,
      updatedAt: FieldValue.serverTimestamp() as FirebaseFirestore.Timestamp,
      userId
    };

    // Firestore에 저장
    const docRef = await db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .add(timetableData);

    logger.info(`학생 시간표 생성 성공: ${docRef.id}`, { userId, studentId: timetableRequest.studentId });

    return {
      success: true,
      data: { id: docRef.id, ...timetableData }
    };
  } catch (error) {
    logger.error("학생 시간표 생성 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "학생 시간표 생성 중 오류가 발생했습니다.");
  }
});

/**
 * 학생별 시간표 목록 조회
 */
export const getStudentTimetables = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { studentId } = data as { studentId: string };

    if (!studentId) {
      throw new HttpsError("invalid-argument", "학생 ID가 필요합니다.");
    }

    // 해당 학생의 시간표 목록 조회
    const snapshot = await db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .where("studentId", "==", studentId)
      .orderBy("createdAt", "desc")
      .get();

    const timetables = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    logger.info(`학생 시간표 목록 조회 성공: ${timetables.length}개`, { userId, studentId });

    return {
      success: true,
      data: timetables
    };
  } catch (error) {
    logger.error("학생 시간표 목록 조회 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "학생 시간표 목록 조회 중 오류가 발생했습니다.");
  }
});

/**
 * 학생별 시간표 업데이트
 */
export const updateStudentTimetable = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { timetableId, updates } = data as {
      timetableId: string;
      updates: UpdateStudentTimetableRequest
    };

    if (!timetableId) {
      throw new HttpsError("invalid-argument", "시간표 ID가 필요합니다.");
    }

    // 시간표 존재 확인
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId);

    const timetableDoc = await timetableRef.get();
    if (!timetableDoc.exists) {
      throw new HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    // 업데이트 데이터 검증
    if (updates.basicSchedule) {
      validateBasicSchedule(updates.basicSchedule);
    }

    // 업데이트 데이터 준비
    const updateData: any = {
      updatedAt: FieldValue.serverTimestamp()
    };

    if (updates.name) updateData.name = updates.name.trim();
    if (updates.description !== undefined) updateData.description = updates.description?.trim();
    if (updates.basicSchedule) updateData.basicSchedule = updates.basicSchedule;
    if (updates.detailedSchedule) updateData.detailedSchedule = updates.detailedSchedule;
    if (updates.autoFillSettings) updateData.autoFillSettings = updates.autoFillSettings;

    // 시간표 업데이트
    await timetableRef.update(updateData);

    logger.info(`학생 시간표 업데이트 성공: ${timetableId}`, { userId });

    return {
      success: true,
      message: "시간표가 업데이트되었습니다."
    };
  } catch (error) {
    logger.error("학생 시간표 업데이트 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "학생 시간표 업데이트 중 오류가 발생했습니다.");
  }
});

/**
 * 학생별 시간표 삭제
 * 시간표와 관련된 모든 데이터를 함께 삭제합니다:
 * - seat_assignments의 timetableId 참조 제거
 * - shared_schedules (해당 시간표의 공유 링크)
 * - schedule_contributions (해당 시간표의 기여 내역)
 */
export const deleteStudentTimetable = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { timetableId } = data as { timetableId: string };

    if (!timetableId) {
      throw new HttpsError("invalid-argument", "시간표 ID가 필요합니다.");
    }

    // 시간표 존재 확인
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId);

    const timetableDoc = await timetableRef.get();
    if (!timetableDoc.exists) {
      throw new HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    // 관련 데이터 일괄 삭제 (batch 사용)
    const batch = db.batch();
    let deleteCount = 0;
    let updateCount = 0;

    // 1. 해당 시간표를 참조하는 좌석 할당의 timetableId 필드 제거
    const assignmentsSnapshot = await db
      .collection("users")
      .doc(userId)
      .collection("seat_assignments")
      .where("timetableId", "==", timetableId)
      .get();

    assignmentsSnapshot.docs.forEach(doc => {
      batch.update(doc.ref, {
        timetableId: FieldValue.delete(),
        updatedAt: FieldValue.serverTimestamp()
      });
      updateCount++;
    });

    // 2. 해당 시간표의 공유 링크 삭제
    const sharedSchedulesSnapshot = await db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .where("timetableId", "==", timetableId)
      .get();

    sharedSchedulesSnapshot.docs.forEach(doc => {
      batch.delete(doc.ref);
      deleteCount++;
    });

    // 3. 해당 시간표의 기여 내역 삭제
    const contributionsSnapshot = await db
      .collection("users")
      .doc(userId)
      .collection("schedule_contributions")
      .where("timetableId", "==", timetableId)
      .get();

    contributionsSnapshot.docs.forEach(doc => {
      batch.delete(doc.ref);
      deleteCount++;
    });

    // 4. 시간표 삭제
    batch.delete(timetableRef);

    // 일괄 실행
    await batch.commit();

    logger.info(`학생 시간표 및 관련 데이터 삭제 성공: ${timetableId}`, {
      userId,
      deletedDocs: deleteCount + 1,
      updatedDocs: updateCount
    });

    return {
      success: true,
      message: `시간표와 관련된 데이터가 삭제되었습니다. (삭제: ${deleteCount + 1}개, 업데이트: ${updateCount}개)`,
      data: {
        updatedAssignments: assignmentsSnapshot.size,
        deletedSharedSchedules: sharedSchedulesSnapshot.size,
        deletedContributions: contributionsSnapshot.size
      }
    };
  } catch (error) {
    logger.error("학생 시간표 삭제 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "학생 시간표 삭제 중 오류가 발생했습니다.");
  }
});

/**
 * 활성 시간표 설정
 */
export const setActiveStudentTimetable = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { timetableId, studentId } = data as {
      timetableId: string;
      studentId: string;
    };

    if (!timetableId || !studentId) {
      throw new HttpsError("invalid-argument", "시간표 ID와 학생 ID가 필요합니다.");
    }

    // 배치 작업으로 처리
    const batch = db.batch();

    // 해당 학생의 모든 시간표를 비활성화
    const existingTimetablesSnapshot = await db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .where("studentId", "==", studentId)
      .get();

    existingTimetablesSnapshot.docs.forEach(doc => {
      batch.update(doc.ref, {
        isActive: false,
        updatedAt: FieldValue.serverTimestamp()
      });
    });

    // 새 시간표를 활성화
    const newTimetableRef = db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId);

    batch.update(newTimetableRef, {
      isActive: true,
      updatedAt: FieldValue.serverTimestamp()
    });

    // 배치 실행
    await batch.commit();

    logger.info(`활성 시간표 설정 성공: ${timetableId}`, { userId, studentId });

    return {
      success: true,
      message: "활성 시간표가 설정되었습니다."
    };
  } catch (error) {
    logger.error("활성 시간표 설정 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "활성 시간표 설정 중 오류가 발생했습니다.");
  }
});

/**
 * 자동 자습시간 채우기 (기본 구현)
 */
export const autoFillStudentTimetable = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { timetableId } = data as { timetableId: string };

    if (!timetableId) {
      throw new HttpsError("invalid-argument", "시간표 ID가 필요합니다.");
    }

    // 시간표 조회
    const timetableDoc = await db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId)
      .get();

    if (!timetableDoc.exists) {
      throw new HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    const timetableData = timetableDoc.data() as StudentTimetableData;
    const { basicSchedule, detailedSchedule, autoFillSettings } = timetableData;

    if (!autoFillSettings.enabled) {
      throw new HttpsError("failed-precondition", "자동 채우기 기능이 비활성화되어 있습니다.");
    }

    // 자동 채우기 로직 (기본 구현)
    const updatedSchedule = { ...detailedSchedule };

    // 활성화된 요일들만 처리
    const activeDays = Object.entries(basicSchedule.dailySchedules)
      .filter(([, schedule]) => schedule.isActive)
      .map(([day]) => day);

    for (const day of activeDays) {
      if (!updatedSchedule[day]) {
        updatedSchedule[day] = { timeSlots: [] };
      }

      // 해당 요일의 등원 시간부터 하원 시간까지 자습 시간 생성
      const daySchedule = basicSchedule.dailySchedules[day as DayOfWeek];
      const startMinutes = parseTimeToMinutes(daySchedule.arrivalTime);
      const endMinutes = parseTimeToMinutes(daySchedule.departureTime);
      const interval = basicSchedule.timeSlotInterval;

      // 기존 일정이 없는 시간대에만 자습 추가
      const existingSlots = updatedSchedule[day].timeSlots;
      const newSlots: TimeSlot[] = [];

      for (let minutes = startMinutes; minutes < endMinutes; minutes += interval) {
        const slotStart = minutesToTime(minutes);
        const slotEnd = minutesToTime(minutes + interval);

        // 기존 일정과 겹치는지 확인
        const hasExisting = existingSlots.some((slot: TimeSlot) =>
          slot.startTime === slotStart && slot.endTime === slotEnd
        );

        if (!hasExisting && autoFillSettings.fillEmptySlots) {
          newSlots.push({
            startTime: slotStart,
            endTime: slotEnd,
            subject: autoFillSettings.defaultSubject,
            type: "self_study",
            isAutoGenerated: true,
            color: "#9E9E9E"
          });
        }
      }

      // 새로운 자습 시간들을 추가
      updatedSchedule[day].timeSlots = [...existingSlots, ...newSlots];
    }

    // 업데이트된 스케줄 저장
    await db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId)
      .update({
        detailedSchedule: updatedSchedule,
        updatedAt: FieldValue.serverTimestamp()
      });

    logger.info(`자동 자습시간 채우기 성공: ${timetableId}`, { userId });

    return {
      success: true,
      data: { detailedSchedule: updatedSchedule }
    };
  } catch (error) {
    logger.error("자동 자습시간 채우기 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "자동 자습시간 채우기 중 오류가 발생했습니다.");
  }
});

/**
 * 시간 슬롯 업데이트
 */
export const updateTimeSlot = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { timetableId, day, timeSlot } = data;

    if (!timetableId || !day || !timeSlot) {
      throw new HttpsError("invalid-argument", "시간표 ID, 요일, 시간 슬롯 정보가 필요합니다.");
    }

    // 시간표 문서 가져오기
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId);

    const timetableDoc = await timetableRef.get();

    if (!timetableDoc.exists) {
      throw new HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    const timetableData = timetableDoc.data() as any;
    const updatedDetailedSchedule = { ...timetableData.detailedSchedule };

    // 해당 요일 스케줄 초기화 (필요한 경우)
    if (!updatedDetailedSchedule[day]) {
      updatedDetailedSchedule[day] = { timeSlots: [] };
    }

    // 기존 슬롯 찾기 및 업데이트/추가
    const existingSlots = updatedDetailedSchedule[day].timeSlots || [];
    const slotIndex = existingSlots.findIndex((slot: TimeSlot) =>
      slot.startTime === timeSlot.startTime && slot.endTime === timeSlot.endTime
    );

    if (slotIndex >= 0) {
      // 기존 슬롯 업데이트
      existingSlots[slotIndex] = { ...existingSlots[slotIndex], ...timeSlot };
    } else {
      // 새 슬롯 추가
      existingSlots.push(timeSlot);
    }

    updatedDetailedSchedule[day].timeSlots = existingSlots;

    // Firestore 업데이트
    await timetableRef.update({
      detailedSchedule: updatedDetailedSchedule,
      updatedAt: FieldValue.serverTimestamp()
    });

    logger.info(`시간 슬롯 업데이트 완료: ${timetableId}`, { userId, day });

    const updatedTimetable = {
      id: timetableId,
      ...timetableData,
      detailedSchedule: updatedDetailedSchedule,
      updatedAt: new Date()
    };

    return {
      success: true,
      data: updatedTimetable
    };
  } catch (error) {
    logger.error("시간 슬롯 업데이트 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "시간 슬롯 업데이트 중 오류가 발생했습니다.");
  }
});

/**
 * 시간 슬롯 삭제
 */
export const deleteTimeSlot = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { timetableId, day, startTime, endTime } = data;

    if (!timetableId || !day || !startTime || !endTime) {
      throw new HttpsError("invalid-argument", "시간표 ID, 요일, 시작시간, 종료시간이 필요합니다.");
    }

    // 시간표 문서 가져오기
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId);

    const timetableDoc = await timetableRef.get();

    if (!timetableDoc.exists) {
      throw new HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    const timetableData = timetableDoc.data() as any;
    const updatedDetailedSchedule = { ...timetableData.detailedSchedule };

    // 해당 요일 스케줄 확인
    if (!updatedDetailedSchedule[day]) {
      throw new HttpsError("not-found", "해당 요일의 스케줄을 찾을 수 없습니다.");
    }

    // 기존 슬롯에서 삭제
    const existingSlots = updatedDetailedSchedule[day].timeSlots || [];
    const filteredSlots = existingSlots.filter((slot: TimeSlot) =>
      !(slot.startTime === startTime && slot.endTime === endTime)
    );

    updatedDetailedSchedule[day].timeSlots = filteredSlots;

    // Firestore 업데이트
    await timetableRef.update({
      detailedSchedule: updatedDetailedSchedule,
      updatedAt: FieldValue.serverTimestamp()
    });

    logger.info(`시간 슬롯 삭제 완료: ${timetableId}`, { userId, day });

    const updatedTimetable = {
      id: timetableId,
      ...timetableData,
      detailedSchedule: updatedDetailedSchedule,
      updatedAt: new Date()
    };

    return {
      success: true,
      data: updatedTimetable
    };
  } catch (error) {
    logger.error("시간 슬롯 삭제 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "시간 슬롯 삭제 중 오류가 발생했습니다.");
  }
});


/**
 * 시간표 복제
 */
export const duplicateStudentTimetable = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { timetableId, newName } = data;

    if (!timetableId) {
      throw new HttpsError("invalid-argument", "시간표 ID가 필요합니다.");
    }

    // 원본 시간표 문서 가져오기
    const originalTimetableRef = db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId);

    const originalTimetableDoc = await originalTimetableRef.get();

    if (!originalTimetableDoc.exists) {
      throw new HttpsError("not-found", "원본 시간표를 찾을 수 없습니다.");
    }

    const originalData = originalTimetableDoc.data() as any;

    // 새 시간표 데이터 생성
    const duplicatedTimetableData = {
      ...originalData,
      name: newName || `${originalData.name} (복사본)`,
      isActive: false,
      isDefault: false,
      createdAt: FieldValue.serverTimestamp() as FirebaseFirestore.Timestamp,
      updatedAt: FieldValue.serverTimestamp() as FirebaseFirestore.Timestamp,
    };

    // 복제된 시간표 저장
    const docRef = await db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .add(duplicatedTimetableData);

    logger.info(`시간표 복제 완료: ${timetableId} -> ${docRef.id}`, { userId });

    const duplicatedTimetable = {
      id: docRef.id,
      ...duplicatedTimetableData,
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return {
      success: true,
      data: duplicatedTimetable
    };
  } catch (error) {
    logger.error("시간표 복제 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "시간표 복제 중 오류가 발생했습니다.");
  }
});

/**
 * 기본 스케줄 업데이트
 */
export const updateBasicSchedule = onCall({
  cors: corsConfig
}, async (request) => {
  try {
    const { auth, data } = request;

    if (!auth) {
      throw new HttpsError("unauthenticated", "인증이 필요합니다.");
    }

    const userId = auth.uid;
    const { timetableId, basicSchedule, autoFillSettings } = data;

    if (!timetableId || !basicSchedule) {
      throw new HttpsError("invalid-argument", "시간표 ID와 기본 스케줄 정보가 필요합니다.");
    }

    // 시간표 문서 가져오기
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId);

    const timetableDoc = await timetableRef.get();

    if (!timetableDoc.exists) {
      throw new HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    // 업데이트할 데이터 준비
    const updateData: any = {
      basicSchedule,
      updatedAt: FieldValue.serverTimestamp()
    };

    if (autoFillSettings) {
      updateData.autoFillSettings = autoFillSettings;
    }

    // Firestore 업데이트
    await timetableRef.update(updateData);

    logger.info(`기본 스케줄 업데이트 완료: ${timetableId}`, { userId });

    // 업데이트된 시간표 데이터 반환
    const updatedDoc = await timetableRef.get();
    const updatedTimetable = {
      id: timetableId,
      ...updatedDoc.data(),
      updatedAt: new Date()
    };

    return {
      success: true,
      data: updatedTimetable
    };
  } catch (error) {
    logger.error("기본 스케줄 업데이트 실패:", error);

    if (error instanceof HttpsError) {
      throw error;
    }

    throw new HttpsError("internal", "기본 스케줄 업데이트 중 오류가 발생했습니다.");
  }
});

