import * as functions from "firebase-functions";
import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as admin from "firebase-admin";
import { v4 as uuidv4 } from "uuid";
import { TimetableEditLock } from "../../types/index";

// DayOfWeek 타입 정의
type DayOfWeek = "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";

// 유틸리티 함수: 시간 문자열을 분으로 변환
const timeToMinutes = (time: string): number => {
  const [hours, minutes] = time.split(":").map(Number);
  return hours * 60 + minutes;
};

// 확장된 편집 권한 인터페이스
interface ExtendedEditPermissions {
  // 기존 권한 (detailedSchedule)
  canAddSlots: boolean;
  canDeleteSlots: boolean;
  canModifySlots: boolean;
  restrictedTimeSlots?: string[];
  
  // 새로운 권한 (basicSchedule)
  canEditBasicSchedule: boolean;
  canEditDailySchedules: boolean; // 요일별 스케줄 편집
  canEditTimeSlotInterval: boolean; // 시간 간격 편집
  
  // 요일별 세부 권한 (실제 dailySchedules 구조 반영)
  dailySchedulePermissions: {
    [key in DayOfWeek]: {
      canEditArrivalTime: boolean; // 해당 요일 등원 시간 편집
      canEditDepartureTime: boolean; // 해당 요일 하원 시간 편집
      canToggleActive: boolean; // 해당 요일 활성화/비활성화
    };
  };
  
  // 전역 제한사항
  timeSlotIntervalOptions?: number[]; // 허용된 시간 간격 옵션
}

// TimeSlot 인터페이스 정의 (기존 코드와 호환)
// interface TimeSlot {
//   id: string;
//   startTime: string;
//   endTime: string;
//   subject: string;
//   teacher?: string;
//   location?: string;
//   type: string;
//   color?: string;
//   notes?: string;
//   isAutoGenerated?: boolean;
// }

// 확장된 변경사항 추적 인터페이스 (필요시 사용)
// interface ExtendedChanges {
//   // 기존 변경사항
//   addedSlots: TimeSlot[];
//   modifiedSlots: string[];
//   deletedSlots: string[];
//   
//   // 새로운 변경사항 (실제 dailySchedules 구조 반영)
//   basicScheduleChanges: {
//     dailyScheduleChanges: {
//       [key in DayOfWeek]?: {
//         arrivalTimeChanged: boolean;
//         departureTimeChanged: boolean;
//         isActiveChanged: boolean;
//         originalSchedule: {
//           arrivalTime: string;
//           departureTime: string;
//           isActive: boolean;
//         };
//         updatedSchedule: {
//           arrivalTime: string;
//           departureTime: string;
//           isActive: boolean;
//         };
//       };
//     };
//     timeSlotIntervalChanged: boolean;
//     originalTimeSlotInterval: number;
//     updatedTimeSlotInterval: number;
//   } | null;
// }

interface SharedSchedule {
  shareToken: string;
  timetableId: string;
  permissions: {
    canEdit: boolean;
    canView: boolean;
    canComment: boolean;
  };
  // 확장된 편집 권한 (기본 스케줄 편집 지원)
  editPermissions?: {
    canAddSlots: boolean;
    canDeleteSlots: boolean;
    canModifySlots: boolean;
    restrictedTimeSlots?: string[];
    canEditBasicSchedule?: boolean;
    canEditDailySchedules?: boolean;
    canEditTimeSlotInterval?: boolean;
    dailySchedulePermissions?: {
      [key: string]: {
        canEditArrivalTime: boolean;
        canEditDepartureTime: boolean;
        canToggleActive: boolean;
      };
    };
    timeSlotIntervalOptions?: number[];
  };
  accessSettings: {
    requireName: boolean;
    requireEmail: boolean;
    maxContributions?: number;
  };
  linkSettings: {
    isActive: boolean;
    expiresAt?: admin.firestore.Timestamp;
    createdAt: admin.firestore.Timestamp;
    lastUsedAt?: admin.firestore.Timestamp;
    usageCount: number;
  };
  title?: string;
  description?: string;
  createdAt: admin.firestore.Timestamp;
  updatedAt: admin.firestore.Timestamp;
}

// StudentTimetableShareLink 인터페이스는 더 이상 사용하지 않음
// SharedSchedule 타입을 직접 사용

interface ScheduleContribution {
  shareToken: string;
  timetableId: string;
  contributor: {
    name?: string;
    email?: string;
    ipAddress: string;
  };
  contributions: {
    dayOfWeek: string;
    timeSlots: {
      startTime: string;
      endTime: string;
      subject: string;
      type: "class" | "self_study";
      color?: string;
      note?: string;
    }[];
  }[];
  status: "pending" | "approved" | "rejected" | "applied";
  appliedAt?: admin.firestore.Timestamp;
  submittedAt: admin.firestore.Timestamp;
  processedAt?: admin.firestore.Timestamp;
  processedBy?: string;
}

/**
 * 학생 시간표 편집 링크 생성 (고유성 보장)
 */
export const createStudentTimetableEditLink = functions.https.onRequest(async (req, res) => {
  console.log("createStudentTimetableEditLink 호출됨");
  console.log("Request Headers:", req.headers);
  console.log("Request Body:", req.body);

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "POST") {
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    // Authorization 헤더에서 토큰 추출
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      console.error("Authorization 헤더가 없거나 형식이 잘못됨:", authHeader);
      res.status(401).json({ error: { message: "인증이 필요합니다.", status: "UNAUTHENTICATED" } });
      return;
    }

    const idToken = authHeader.split("Bearer ")[1];
    console.log("ID 토큰 추출됨:", idToken ? "성공" : "실패");

    // Firebase Admin SDK로 토큰 검증
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    console.log("토큰 검증 성공:", {
      uid: decodedToken.uid,
      email: decodedToken.email,
      email_verified: decodedToken.email_verified
    });

    const userId = decodedToken.uid;

    // 요청 데이터 추출
    const {
      studentId,
      timetableId,
      expiresInDays = 7,
      title,
      description,
      editPermissions
    } = req.body.data || req.body;

    if (!studentId || !timetableId) {
      res.status(400).json({ error: { message: "학생 ID와 시간표 ID가 필요합니다.", status: "INVALID_ARGUMENT" } });
      return;
    }
    const db = admin.firestore();

    // 1. 기존 활성 링크 확인 및 비활성화
    const existingLinksQuery = await db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .where("timetableId", "==", timetableId)
      .where("linkSettings.isActive", "==", true)
      .get();

    const batch = db.batch();

    // 기존 활성 링크들을 비활성화
    existingLinksQuery.docs.forEach(doc => {
      batch.update(doc.ref, {
        "linkSettings.isActive": false,
        "linkSettings.deactivatedAt": admin.firestore.Timestamp.now(),
        "updatedAt": admin.firestore.Timestamp.now()
      });
    });

    // 기존 편집 상태도 정리
    const existingEditStatesQuery = await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_states")
      .where("timetableId", "==", timetableId)
      .where("status", "==", "active")
      .get();

    existingEditStatesQuery.docs.forEach(doc => {
      batch.update(doc.ref, {
        status: "expired",
        expiredAt: admin.firestore.Timestamp.now()
      });
    });

    // 2. 학생 존재 확인
    const studentDoc = await db
      .collection("users")
      .doc(userId)
      .collection("students")
      .doc(studentId)
      .get();

    if (!studentDoc.exists) {
      throw new functions.https.HttpsError("not-found", "학생을 찾을 수 없습니다.");
    }

    // 3. 시간표 존재 확인
    const timetableRef = db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .doc(timetableId);
    const timetableDoc = await timetableRef.get();

    if (!timetableDoc.exists) {
      throw new functions.https.HttpsError("not-found", "학생 시간표를 찾을 수 없습니다.");
    }

    const timetableData = timetableDoc.data();
    if (timetableData?.studentId !== studentId) {
      throw new functions.https.HttpsError("invalid-argument", "해당 학생의 시간표가 아닙니다.");
    }

    // 4. 공유 토큰 및 편집 상태 생성
    const shareToken = uuidv4();
    const editStateId = uuidv4();
    const sharedScheduleRef = db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .doc();

    // 만료일 설정
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + expiresInDays);

    const sharedScheduleData: SharedSchedule = {
      shareToken,
      timetableId,
      permissions: {
        canEdit: true,
        canView: true,
        canComment: false
      },
      editPermissions: editPermissions || {
        canAddSlots: true,
        canDeleteSlots: true,
        canModifySlots: true,
        restrictedTimeSlots: [],
        canEditBasicSchedule: true,
        canEditDailySchedules: true,
        canEditTimeSlotInterval: true,
        dailySchedulePermissions: {
          monday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
          tuesday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
          wednesday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
          thursday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
          friday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
          saturday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
          sunday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true }
        },
        timeSlotIntervalOptions: [15, 30, 45, 60]
      },
      accessSettings: {
        requireName: false,
        requireEmail: false,
        maxContributions: 1
      },
      linkSettings: {
        isActive: true,
        expiresAt: admin.firestore.Timestamp.fromDate(expiresAt),
        createdAt: admin.firestore.Timestamp.now(),
        usageCount: 0
      },
      title: title || `${timetableData?.studentName || "학생"} 시간표 편집`,
      description: description || `${timetableData?.name || "시간표"}를 편집해주세요.`,
      createdAt: admin.firestore.Timestamp.now(),
      updatedAt: admin.firestore.Timestamp.now()
    };

    // 5. 편집 상태 생성 (Firebase 기반 상태 관리)
    const editStateData = {
      id: editStateId,
      shareToken,
      timetableId,
      studentId,
      originalTimetable: timetableData,
      currentTimetable: timetableData, // 초기에는 원본과 동일
      status: "active", // active, submitted, approved, rejected, expired
      createdAt: admin.firestore.Timestamp.now(),
      updatedAt: admin.firestore.Timestamp.now(),
      lastAccessedAt: admin.firestore.Timestamp.now(),
      expiresAt: admin.firestore.Timestamp.fromDate(expiresAt),
      changes: {
        addedSlots: [],
        modifiedSlots: [],
        deletedSlots: []
      },
      submissionNotes: null,
      submittedAt: null,
      reviewedAt: null,
      reviewedBy: null
    };

    // 6. 배치로 모든 변경사항 적용
    batch.set(sharedScheduleRef, sharedScheduleData);
    batch.set(db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_states")
      .doc(editStateId), editStateData);

    // 원본 시간표에 편집 상태 업데이트
    batch.update(timetableRef, {
      isBeingEdited: true,
      editLinkToken: shareToken,
      editStateId: editStateId,
      editLinkExpiresAt: admin.firestore.Timestamp.fromDate(expiresAt),
      updatedAt: admin.firestore.Timestamp.now()
    });

    await batch.commit();

    const result = {
      success: true,
      message: "학생 시간표 편집 링크가 생성되었습니다.",
      data: {
        shareId: sharedScheduleRef.id,
        editStateId: editStateId,
        shareToken,
        shareUrl: `${process.env.BASE_URL || "http://localhost:3000"}/student-timetable-edit/${shareToken}`,
        expiresAt: expiresAt.toISOString(),
        studentName: timetableData?.studentName,
        timetableName: timetableData?.name,
        isNewLink: existingLinksQuery.docs.length > 0 ? false : true,
        deactivatedLinksCount: existingLinksQuery.docs.length
      }
    };

    console.log("링크 생성 성공:", result);
    res.status(200).json(result);
  } catch (error) {
    console.error("학생 시간표 편집 링크 생성 오류:", error);

    if (error instanceof functions.https.HttpsError) {
      res.status(400).json({ error: { message: error.message, status: error.code } });
      return;
    }

    res.status(500).json({ error: { message: "서버 오류가 발생했습니다.", status: "INTERNAL" } });
  }
});

/**
 * 편집 상태 업데이트 (Firebase 기반 임시 저장)
 */
export const updateEditState = functions.https.onRequest(async (req: functions.https.Request, res: any) => {
  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type");
  
  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }
  
  if (req.method !== "POST") {
    res.status(405).send("Method Not Allowed");
    return;
  }

  try {
    const { shareToken, currentTimetable, changes, updatedBasicSchedule, basicScheduleChanges } = req.body;

    if (!shareToken || !currentTimetable) {
      res.status(400).json({ error: "필수 데이터가 누락되었습니다." });
      return;
    }

    const db = admin.firestore();

    // 공유 스케줄 조회
    const sharedScheduleQuery = await db
      .collectionGroup("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (sharedScheduleQuery.empty) {
      res.status(404).json({ error: "유효하지 않은 링크입니다." });
      return;
    }

    const sharedScheduleDoc = sharedScheduleQuery.docs[0];
    const userId = sharedScheduleDoc.ref.parent.parent?.id;

    if (!userId) {
      res.status(500).json({ error: "사용자 정보를 찾을 수 없습니다." });
      return;
    }

    // 편집 상태 조회
    const editStateQuery = await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_states")
      .where("shareToken", "==", shareToken)
      .where("status", "==", "active")
      .limit(1)
      .get();

    if (editStateQuery.empty) {
      res.status(404).json({ error: "편집 상태를 찾을 수 없습니다." });
      return;
    }

    const editStateDoc = editStateQuery.docs[0];

    // 만료 확인
    const editStateData = editStateDoc.data();
    if (editStateData.expiresAt && editStateData.expiresAt.toDate() < new Date()) {
      res.status(410).json({ error: "편집 세션이 만료되었습니다." });
      return;
    }

    // 실제 권한 정보 가져오기 (shared_schedules에서)
    const sharedScheduleData = sharedScheduleDoc.data();
    const permissions: ExtendedEditPermissions = sharedScheduleData.editPermissions || {
      canAddSlots: true,
      canDeleteSlots: true,
      canModifySlots: true,
      restrictedTimeSlots: [],
      canEditBasicSchedule: true,
      canEditDailySchedules: true,
      canEditTimeSlotInterval: true,
      dailySchedulePermissions: {
        monday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
        tuesday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
        wednesday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
        thursday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
        friday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
        saturday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true },
        sunday: { canEditArrivalTime: true, canEditDepartureTime: true, canToggleActive: true }
      },
      timeSlotIntervalOptions: [15, 30, 45, 60]
    };

    // basicSchedule 변경사항 처리 (실제 DB 시간 제한 반영)
    if (basicScheduleChanges && updatedBasicSchedule) {
      console.log("기본 스케줄 변경사항 처리 시작:", {
        shareToken: shareToken.substring(0, 8) + "...",
        hasDailyChanges: !!basicScheduleChanges.dailyScheduleChanges,
        hasIntervalChanges: basicScheduleChanges.timeSlotIntervalChanged
      });

      const { dailyScheduleChanges, timeSlotIntervalChanged } = basicScheduleChanges;
      
      // 권한 검증
      if (!permissions.canEditBasicSchedule) {
        console.warn("기본 스케줄 편집 권한 없음:", {
          shareToken: shareToken.substring(0, 8) + "...",
          canEditBasicSchedule: permissions.canEditBasicSchedule
        });
        res.status(403).json({ error: "기본 스케줄 편집 권한이 없습니다." });
        return;
      }
      
      // 요일별 권한 및 시간 제한 검증 (실제 DB 구조 반영)
      for (const [day, dayChanges] of Object.entries(dailyScheduleChanges || {})) {
        const dayPermissions = permissions.dailySchedulePermissions[day as DayOfWeek];
        
        if (!dayPermissions) {
          console.error("요일 권한 정보 없음:", { day, shareToken: shareToken.substring(0, 8) + "..." });
          res.status(500).json({ error: `${day}의 권한 정보를 찾을 수 없습니다.` });
          return;
        }

        const typedDayChanges = dayChanges as {
          arrivalTimeChanged: boolean;
          departureTimeChanged: boolean;
          isActiveChanged: boolean;
          originalSchedule: {
            arrivalTime: string;
            departureTime: string;
            isActive: boolean;
          };
          updatedSchedule: {
            arrivalTime: string;
            departureTime: string;
            isActive: boolean;
          };
        };
        
        console.log(`요일 ${day} 권한 검증:`, {
          arrivalTimeChanged: typedDayChanges.arrivalTimeChanged,
          departureTimeChanged: typedDayChanges.departureTimeChanged,
          isActiveChanged: typedDayChanges.isActiveChanged,
          canEditArrivalTime: dayPermissions.canEditArrivalTime,
          canEditDepartureTime: dayPermissions.canEditDepartureTime,
          canToggleActive: dayPermissions.canToggleActive
        });
        
        if (typedDayChanges.arrivalTimeChanged && !dayPermissions.canEditArrivalTime) {
          console.warn(`${day} 등원 시간 편집 권한 없음:`, {
            shareToken: shareToken.substring(0, 8) + "...",
            canEditArrivalTime: dayPermissions.canEditArrivalTime
          });
          res.status(403).json({ error: `${day} 등원 시간 편집 권한이 없습니다.` });
          return;
        }
        
        if (typedDayChanges.departureTimeChanged && !dayPermissions.canEditDepartureTime) {
          console.warn(`${day} 하원 시간 편집 권한 없음:`, {
            shareToken: shareToken.substring(0, 8) + "...",
            canEditDepartureTime: dayPermissions.canEditDepartureTime
          });
          res.status(403).json({ error: `${day} 하원 시간 편집 권한이 없습니다.` });
          return;
        }
        
        // 실제 DB 시간 제한 검증
        const { updatedSchedule } = typedDayChanges;
        
        console.log(`${day} 시간 검증:`, {
          arrivalTime: updatedSchedule.arrivalTime,
          departureTime: updatedSchedule.departureTime,
          isActive: updatedSchedule.isActive
        });
        
        // 등원/하원 시간 순서 검증
        if (updatedSchedule.arrivalTime >= updatedSchedule.departureTime) {
          console.error(`${day} 시간 순서 오류:`, {
            arrivalTime: updatedSchedule.arrivalTime,
            departureTime: updatedSchedule.departureTime,
            shareToken: shareToken.substring(0, 8) + "..."
          });
          res.status(400).json({ error: `${day}의 하원 시간은 등원 시간보다 늦어야 합니다.` });
          return;
        }
        
        // 16시간 제한 검증 (실제 DB 제한 반영)
        const startMinutes = timeToMinutes(updatedSchedule.arrivalTime);
        const endMinutes = timeToMinutes(updatedSchedule.departureTime);
        const durationMinutes = endMinutes - startMinutes;
        
        if (durationMinutes > 16 * 60) {
          console.error(`${day} 시간 초과 오류:`, {
            arrivalTime: updatedSchedule.arrivalTime,
            departureTime: updatedSchedule.departureTime,
            durationMinutes: durationMinutes,
            maxMinutes: 16 * 60,
            shareToken: shareToken.substring(0, 8) + "..."
          });
          res.status(400).json({ error: `${day}은 하루 16시간을 초과할 수 없습니다.` });
          return;
        }
      }
      
      // 시간 간격 검증 (실제 DB 제한 반영)
      if (timeSlotIntervalChanged) {
        const newInterval = basicScheduleChanges.updatedTimeSlotInterval;
        
        console.log("시간 간격 검증:", {
          newInterval: newInterval,
          minInterval: 15,
          shareToken: shareToken.substring(0, 8) + "..."
        });
        
        if (newInterval < 15) {
          console.error("시간 간격 최소값 위반:", {
            newInterval: newInterval,
            minInterval: 15,
            shareToken: shareToken.substring(0, 8) + "..."
          });
          res.status(400).json({ error: "시간 간격은 최소 15분 이상이어야 합니다." });
          return;
        }
        
        // 허용된 간격 옵션 검증
        if (permissions.timeSlotIntervalOptions && !permissions.timeSlotIntervalOptions.includes(newInterval)) {
          console.error("허용되지 않은 시간 간격:", {
            newInterval: newInterval,
            allowedOptions: permissions.timeSlotIntervalOptions,
            shareToken: shareToken.substring(0, 8) + "..."
          });
          res.status(400).json({ 
            error: `허용되지 않은 시간 간격입니다. 허용된 간격: ${permissions.timeSlotIntervalOptions.join(", ")}분` 
          });
          return;
        }
      }
      
      console.log("기본 스케줄 변경사항 검증 완료:", {
        shareToken: shareToken.substring(0, 8) + "...",
        changedDays: Object.keys(dailyScheduleChanges || {}),
        intervalChanged: timeSlotIntervalChanged
      });
    }

    // 편집 상태 업데이트 (확장된 changes 객체 포함)
    const updateData: any = {
      currentTimetable: currentTimetable,
      changes: {
        addedSlots: changes?.addedSlots || [],
        modifiedSlots: changes?.modifiedSlots || [],
        deletedSlots: changes?.deletedSlots || [],
        basicScheduleChanges: basicScheduleChanges || null // 직접 포함
      },
      updatedAt: admin.firestore.Timestamp.now(),
      lastAccessedAt: admin.firestore.Timestamp.now()
    };

    // basicSchedule 변경사항이 있으면 currentTimetable에 반영
    if (basicScheduleChanges && updatedBasicSchedule) {
      console.log("basicSchedule 업데이트 적용:", {
        shareToken: shareToken.substring(0, 8) + "...",
        updatedBasicSchedule: updatedBasicSchedule
      });

      // currentTimetable 전체를 업데이트 (basicSchedule 포함)
      updateData.currentTimetable = {
        ...currentTimetable,
        basicSchedule: updatedBasicSchedule // 명시적으로 포함
      };
    }

    await editStateDoc.ref.update(updateData);

    res.status(200).json({
      success: true,
      message: "편집 상태가 저장되었습니다."
    });
  } catch (error) {
    console.error("편집 상태 업데이트 오류:", error);
    res.status(500).json({ error: "서버 오류가 발생했습니다." });
  }
});

/**
 * 편집 상태 조회
 */
export const getEditState = functions.https.onRequest(async (req, res) => {
  console.log("=== getEditState 호출됨 ===");
  console.log("Request Headers:", req.headers);
  console.log("Request Query:", req.query);
  console.log("Request Method:", req.method);
  console.log("Request Origin:", req.get("Origin"));

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    console.log("OPTIONS 요청 처리");
    res.status(204).send("");
    return;
  }

  if (req.method !== "GET") {
    console.log("잘못된 메서드:", req.method);
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    const shareToken = req.query.token as string;

    if (!shareToken) {
      res.status(400).json({ error: { message: "공유 토큰이 필요합니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    // 편집 상태 조회
    const editStateQuery = await admin
      .firestore()
      .collectionGroup("timetable_edit_states")
      .where("shareToken", "==", shareToken)
      .where("status", "==", "active")
      .limit(1)
      .get();

    if (editStateQuery.empty) {
      res.status(404).json({ error: { message: "편집 상태를 찾을 수 없습니다.", status: "NOT_FOUND" } });
      return;
    }

    const editStateDoc = editStateQuery.docs[0];
    const editStateData = editStateDoc.data();

    // 만료 확인
    if (editStateData.expiresAt && editStateData.expiresAt.toDate() < new Date()) {
      // 만료된 상태 업데이트
      await editStateDoc.ref.update({
        status: "expired",
        expiredAt: admin.firestore.Timestamp.now()
      });

      res.status(410).json({ error: { message: "편집 세션이 만료되었습니다.", status: "FAILED_PRECONDITION" } });
      return;
    }

    // 마지막 접근 시간 업데이트
    await editStateDoc.ref.update({
      lastAccessedAt: admin.firestore.Timestamp.now()
    });

    const result = {
      success: true,
      data: {
        editStateId: editStateDoc.id,
        originalTimetable: editStateData.originalTimetable,
        currentTimetable: editStateData.currentTimetable,
        changes: editStateData.changes,
        createdAt: editStateData.createdAt.toDate().toISOString(),
        updatedAt: editStateData.updatedAt.toDate().toISOString(),
        expiresAt: editStateData.expiresAt?.toDate().toISOString() || null
      }
    };

    res.status(200).json(result);
  } catch (error) {
    console.error("편집 상태 조회 오류:", error);
    res.status(500).json({ error: { message: "서버 오류가 발생했습니다.", status: "INTERNAL" } });
  }
});

/**
 * 공유된 시간표 데이터 조회 (편집 상태 포함)
 */
export const getSharedTimetableData = functions.https.onRequest(async (req, res) => {
  console.log("=== getSharedTimetableData 호출됨 ===");
  console.log("Request Headers:", req.headers);
  console.log("Request Query:", req.query);
  console.log("Request Method:", req.method);
  console.log("Request Origin:", req.get("Origin"));

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    console.log("OPTIONS 요청 처리");
    res.status(204).send("");
    return;
  }

  if (req.method !== "GET") {
    console.log("잘못된 메서드:", req.method);
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    const shareToken = req.query.token as string;

    if (!shareToken) {
      res.status(400).json({ error: { message: "공유 토큰이 필요합니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    // 공유 스케줄 조회 (linkType 조건 제거)
    const sharedScheduleQuery = await admin
      .firestore()
      .collectionGroup("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (sharedScheduleQuery.empty) {
      res.status(404).json({ error: { message: "유효하지 않은 링크입니다.", status: "NOT_FOUND" } });
      return;
    }

    const sharedScheduleDoc = sharedScheduleQuery.docs[0];
    const sharedScheduleData = sharedScheduleDoc.data();

    console.log("공유 스케줄 데이터:", JSON.stringify(sharedScheduleData, null, 2));

    // 데이터 구조 검증 (안전한 접근)
    if (!sharedScheduleData || typeof sharedScheduleData !== "object") {
      console.error("유효하지 않은 데이터 구조:", sharedScheduleData);
      res.status(500).json({ error: { message: "유효하지 않은 데이터 구조입니다.", status: "INTERNAL" } });
      return;
    }

    // linkSettings 안전하게 접근
    const linkSettings = sharedScheduleData.linkSettings;
    if (!linkSettings || typeof linkSettings !== "object") {
      console.error("linkSettings가 없습니다:", sharedScheduleData);
      res.status(500).json({ error: { message: "링크 설정을 찾을 수 없습니다.", status: "INTERNAL" } });
      return;
    }

    // 만료 확인 (안전한 접근)
    if (linkSettings.expiresAt) {
      try {
        const expiresAt = linkSettings.expiresAt.toDate ? linkSettings.expiresAt.toDate() : new Date(linkSettings.expiresAt);
        if (expiresAt < new Date()) {
          res.status(410).json({ error: { message: "링크가 만료되었습니다.", status: "FAILED_PRECONDITION" } });
          return;
        }
      } catch (error) {
        console.error("만료일 처리 오류:", error);
        // 만료일 처리 실패 시 계속 진행
      }
    }

    // 활성화 상태 확인 (안전한 접근)
    if (linkSettings.isActive === false) {
      res.status(403).json({ error: { message: "비활성화된 링크입니다.", status: "FAILED_PRECONDITION" } });
      return;
    }

    const userId = sharedScheduleDoc.ref.parent.parent?.id;
    if (!userId) {
      res.status(500).json({ error: { message: "사용자 정보를 찾을 수 없습니다.", status: "INTERNAL" } });
      return;
    }

    // timetableId 안전하게 접근
    const timetableId = sharedScheduleData.timetableId;
    if (!timetableId) {
      console.error("timetableId가 없습니다:", sharedScheduleData);
      res.status(500).json({ error: { message: "시간표 ID를 찾을 수 없습니다.", status: "INTERNAL" } });
      return;
    }

    // 시간표 데이터 조회
    const timetableRef = admin
      .firestore()
      .doc(`users/${userId}/student_timetables/${timetableId}`);

    const timetableDoc = await timetableRef.get();

    if (!timetableDoc.exists) {
      res.status(404).json({ error: { message: "시간표 정보를 찾을 수 없습니다.", status: "NOT_FOUND" } });
      return;
    }

    const timetableData = { id: timetableDoc.id, ...timetableDoc.data() } as any;

    // permissions 안전하게 접근
    const permissions = sharedScheduleData.permissions || {
      canEdit: true,
      canView: true,
      canComment: false
    };

    // expiresAt 안전하게 접근
    let expiresAtString = null;
    if (linkSettings.expiresAt) {
      try {
        const expiresAt = linkSettings.expiresAt.toDate ? linkSettings.expiresAt.toDate() : new Date(linkSettings.expiresAt);
        expiresAtString = expiresAt.toISOString();
      } catch (error) {
        console.error("만료일 문자열 변환 오류:", error);
      }
    }

    const result = {
      success: true,
      data: {
        student: {
          id: timetableData.studentId || "unknown",
          name: timetableData.studentName || "학생",
          ...timetableData
        },
        timetable: timetableData,
        permissions: permissions,
        expiresAt: expiresAtString,
        shareId: sharedScheduleDoc.id
      }
    };

    console.log("공유 시간표 데이터 조회 성공:", result);
    res.status(200).json(result);
  } catch (error) {
    console.error("공유 시간표 데이터 조회 오류:", error);

    if (error instanceof functions.https.HttpsError) {
      res.status(400).json({ error: { message: error.message, status: error.code } });
      return;
    }

    res.status(500).json({ error: { message: "서버 오류가 발생했습니다.", status: "INTERNAL" } });
  }
});

/**
 * 시간표 편집 제출
 */

export const submitTimetableEdit = functions.https.onRequest(async (req: functions.https.Request, res: any) => {
  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type");
  
  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }
  
  if (req.method !== "POST") {
    res.status(405).send("Method Not Allowed");
    return;
  }

  try {
    const { shareToken, submissionNotes } = req.body;

    if (!shareToken) {
      res.status(400).json({ error: "공유 토큰이 필요합니다." });
      return;
    }

    // 공유 스케줄 조회로 userId 찾기
    const sharedScheduleQuery = await admin
      .firestore()
      .collectionGroup("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (sharedScheduleQuery.empty) {
      res.status(404).json({ error: "유효하지 않은 링크입니다." });
      return;
    }

    const sharedScheduleDoc = sharedScheduleQuery.docs[0];
    const userId = sharedScheduleDoc.ref.parent.parent?.id;

    if (!userId) {
      res.status(500).json({ error: "사용자 정보를 찾을 수 없습니다." });
      return;
    }

    // 편집 상태 조회
    const editStateQuery = await admin
      .firestore()
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_states")
      .where("shareToken", "==", shareToken)
      .where("status", "==", "active")
      .limit(1)
      .get();

    if (editStateQuery.empty) {
      res.status(404).json({ error: "편집 상태를 찾을 수 없습니다." });
      return;
    }

    const editStateDoc = editStateQuery.docs[0];
    const editStateData = editStateDoc.data();

    // 만료 확인
    if (editStateData.expiresAt && editStateData.expiresAt.toDate() < new Date()) {
      res.status(410).json({ error: "편집 세션이 만료되었습니다." });
      return;
    }

    // 변경사항이 없으면 제출 불가 (기본 스케줄 변경사항 포함)
    const changes = editStateData.changes;
    const detailedChanges = (changes.addedSlots?.length || 0) +
                           (changes.modifiedSlots?.length || 0) +
                           (changes.deletedSlots?.length || 0);
    const basicChanges = changes.basicScheduleChanges ? 1 : 0;
    const totalChanges = detailedChanges + basicChanges;

    if (totalChanges === 0) {
      res.status(400).json({ error: "변경사항이 없습니다." });
      return;
    }

    // 편집 상태를 제출됨으로 업데이트
    await editStateDoc.ref.update({
      status: "submitted",
      submissionNotes: submissionNotes || null,
      submittedAt: admin.firestore.Timestamp.now()
    });

    // 공유 링크를 비활성화 (한 번만 제출 가능)
    await sharedScheduleDoc.ref.update({
      "linkSettings.isActive": false,
      "linkSettings.submittedAt": admin.firestore.Timestamp.now(),
      "updatedAt": admin.firestore.Timestamp.now()
    });

    // 원본 시간표의 편집 상태 업데이트
    await admin
      .firestore()
      .doc(`users/${userId}/student_timetables/${editStateData.timetableId}`)
      .update({
        isBeingEdited: false,
        editLinkToken: null,
        editStateId: null,
        editLinkExpiresAt: null,
        pendingSubmission: true,
        pendingSubmissionId: editStateDoc.id,
        updatedAt: admin.firestore.Timestamp.now()
      });

    // 관리자 알림을 위한 schedule_contributions 문서 생성
    try {
      const studentTimetableData = await admin
        .firestore()
        .doc(`users/${userId}/student_timetables/${editStateData.timetableId}`)
        .get();

      const studentData = await admin
        .firestore()
        .doc(`users/${userId}`)
        .get();

      // 데이터 유효성 검증
      if (!editStateData.currentTimetable || !editStateData.currentTimetable.detailedSchedule) {
        throw new functions.https.HttpsError("invalid-argument", "편집 상태 데이터가 올바르지 않습니다.");
      }

      const contributionData = {
        contributionType: "student_timetable_edit",
        shareToken: shareToken,
        timetableId: editStateData.timetableId,
        studentId: userId,
        originalTimetableId: editStateData.timetableId,
        originalVersion: studentTimetableData.data()?.version || "1.0",
        proposedTimetable: {
          // 원본 시간표의 모든 속성을 그대로 복사 (basicSchedule, autoFillSettings 등 모든 구조 보존)
          ...studentTimetableData.data(),

          // 그 중에서 detailedSchedule만 학생이 편집한 버전으로 덮어쓰기
          detailedSchedule: editStateData.currentTimetable.detailedSchedule || {
            monday: { timeSlots: [] },
            tuesday: { timeSlots: [] },
            wednesday: { timeSlots: [] },
            thursday: { timeSlots: [] },
            friday: { timeSlots: [] },
            saturday: { timeSlots: [] },
            sunday: { timeSlots: [] }
          },

          // 기본 스케줄 변경사항이 있으면 반영
          ...(changes.basicScheduleChanges ? {
            basicSchedule: editStateData.currentTimetable.basicSchedule
          } : {}),

          // 변경사항 추적 필드 추가
          modifiedSlots: changes.modifiedSlots || [],
          addedSlots: changes.addedSlots || [],
          deletedSlots: changes.deletedSlots || [],

          // 변경사항 메타데이터 추가
          hasBasicScheduleChanges: !!changes.basicScheduleChanges
        },
        submissionNotes: submissionNotes || null,
        editStartedAt: editStateData.createdAt,
        status: "pending",
        submittedAt: admin.firestore.Timestamp.now(),
        metadata: {
          studentName: studentData.data()?.name || "알 수 없음",
          timetableName: studentTimetableData.data()?.name || "시간표",
          totalChanges: totalChanges
        }
      };

      // schedule_contributions 컬렉션에 알림 데이터 저장
      const newContributionRef = admin
        .firestore()
        .collection("users")
        .doc(userId)
        .collection("schedule_contributions")
        .doc();

      // id 필드를 contributionData에 추가
      const contributionDataWithId = {
        ...contributionData,
        id: newContributionRef.id
      };

      await newContributionRef.set(contributionDataWithId);

      console.log("관리자 알림 데이터가 생성되었습니다:", contributionData);
    } catch (notificationError) {
      console.error("관리자 알림 생성 오류:", notificationError);
      // 알림 생성 실패해도 기존 로직은 계속 진행
    }

    res.status(200).json({
      success: true,
      message: "시간표 편집 내용이 성공적으로 제출되었습니다. 관리자 승인을 기다리고 있습니다.",
      data: {
        editStateId: editStateDoc.id,
        status: "submitted",
        submittedAt: new Date().toISOString(),
        changes: changes,
        totalChanges: totalChanges
      }
    });
  } catch (error) {
    console.error("시간표 편집 제출 오류:", error);
    res.status(500).json({ error: "서버 오류가 발생했습니다." });
  }
});

/**
 * 시간표 공유 링크 생성
 */
export const createShareLink = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const {
    timetableId,
    permissions = { canEdit: true, canView: true, canComment: false },
    accessSettings = { requireName: false, requireEmail: false },
    expiresInDays,
    title,
    description
  } = data;

  if (!timetableId) {
    throw new functions.https.HttpsError("invalid-argument", "timetableId가 필요합니다.");
  }

  try {
    const db = admin.firestore();

    // 시간표 존재 확인
    const timetableRef = db.collection("users").doc(userId).collection("timetables").doc(timetableId);
    const timetableDoc = await timetableRef.get();

    if (!timetableDoc.exists) {
      throw new functions.https.HttpsError("not-found", "시간표를 찾을 수 없습니다.");
    }

    // 공유 토큰 생성
    const shareToken = uuidv4();
    const sharedScheduleRef = db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .doc();

    const linkSettings: any = {
      isActive: true,
      createdAt: admin.firestore.Timestamp.now(),
      usageCount: 0
    };

    if (expiresInDays) {
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + expiresInDays);
      linkSettings.expiresAt = admin.firestore.Timestamp.fromDate(expiresAt);
    }

    const sharedScheduleData: SharedSchedule = {
      shareToken,
      timetableId,
      permissions,
      accessSettings,
      linkSettings,
      title,
      description,
      createdAt: admin.firestore.Timestamp.now(),
      updatedAt: admin.firestore.Timestamp.now()
    };

    await sharedScheduleRef.set(sharedScheduleData);

    // 원본 시간표에 공유 상태 업데이트
    await timetableRef.update({
      isShared: true,
      shareToken,
      shareSettings: {
        allowEdit: permissions.canEdit,
        allowView: permissions.canView,
        expiresAt: linkSettings.expiresAt || null
      },
      updatedAt: admin.firestore.Timestamp.now()
    });

    return {
      success: true,
      message: "공유 링크가 생성되었습니다.",
      data: {
        shareId: sharedScheduleRef.id,
        shareToken,
        shareUrl: `${process.env.VITE_BASE_URL || "http://localhost:3000"}/shared-schedule/${shareToken}`
      }
    };
  } catch (error) {
    console.error("공유 링크 생성 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 공유 링크로 시간표 조회 (공개 접근 가능)
 */
export const getSharedSchedule = functions.https.onRequest(async (req, res) => {
  const { shareToken } = req.params;

  if (!shareToken) {
    res.status(400).json({ success: false, error: "공유 토큰이 필요합니다." });
    return;
  }

  try {
    const db = admin.firestore();

    // 공유 링크 정보 조회
    const sharedScheduleQuery = await db
      .collectionGroup("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (sharedScheduleQuery.empty) {
      res.status(404).json({ success: false, error: "공유 링크를 찾을 수 없습니다." });
      return;
    }

    const sharedScheduleDoc = sharedScheduleQuery.docs[0];
    const sharedScheduleData = sharedScheduleDoc.data() as SharedSchedule;

    // 링크 활성 상태 및 만료 확인
    if (!sharedScheduleData.linkSettings.isActive) {
      res.status(403).json({ success: false, error: "비활성화된 공유 링크입니다." });
      return;
    }

    if (sharedScheduleData.linkSettings.expiresAt &&
        sharedScheduleData.linkSettings.expiresAt.toDate() < new Date()) {
      res.status(410).json({ success: false, error: "만료된 공유 링크입니다." });
      return;
    }

    // 시간표 소유자 ID 추출
    const userId = sharedScheduleDoc.ref.parent.parent?.id;
    if (!userId) {
      res.status(500).json({ success: false, error: "시간표 소유자를 확인할 수 없습니다." });
      return;
    }

    // 원본 시간표 조회
    const timetableDoc = await db
      .collection("users")
      .doc(userId)
      .collection("timetables")
      .doc(sharedScheduleData.timetableId)
      .get();

    if (!timetableDoc.exists) {
      res.status(404).json({ success: false, error: "시간표를 찾을 수 없습니다." });
      return;
    }

    // 사용 카운트 업데이트
    await sharedScheduleDoc.ref.update({
      "linkSettings.usageCount": admin.firestore.FieldValue.increment(1),
      "linkSettings.lastUsedAt": admin.firestore.Timestamp.now()
    });

    res.json({
      success: true,
      data: {
        timetable: { id: timetableDoc.id, ...timetableDoc.data() },
        shareInfo: {
          title: sharedScheduleData.title,
          description: sharedScheduleData.description,
          permissions: sharedScheduleData.permissions,
          accessSettings: sharedScheduleData.accessSettings
        }
      }
    });
  } catch (error) {
    console.error("공유 시간표 조회 오류:", error);
    res.status(500).json({ success: false, error: "서버 오류가 발생했습니다." });
  }
});

/**
 * 외부 사용자가 시간표에 일정 기여
 */
export const contributeSchedule = functions.https.onRequest(async (req, res) => {
  const { shareToken } = req.params;
  const { contributor, contributions } = req.body;

  if (!shareToken || !contributions) {
    res.status(400).json({ success: false, error: "필수 필드가 누락되었습니다." });
    return;
  }

  try {
    const db = admin.firestore();

    // 공유 링크 확인
    const sharedScheduleQuery = await db
      .collectionGroup("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (sharedScheduleQuery.empty) {
      res.status(404).json({ success: false, error: "공유 링크를 찾을 수 없습니다." });
      return;
    }

    const sharedScheduleDoc = sharedScheduleQuery.docs[0];
    const sharedScheduleData = sharedScheduleDoc.data() as SharedSchedule;

    // 편집 권한 확인
    if (!sharedScheduleData.permissions.canEdit) {
      res.status(403).json({ success: false, error: "편집 권한이 없습니다." });
      return;
    }

    // 시간표 소유자 ID 추출
    const userId = sharedScheduleDoc.ref.parent.parent?.id;
    if (!userId) {
      res.status(500).json({ success: false, error: "시간표 소유자를 확인할 수 없습니다." });
      return;
    }

    // 기여 데이터 저장
    const contributionRef = db
      .collection("users")
      .doc(userId)
      .collection("schedule_contributions")
      .doc();

    const contributionData: ScheduleContribution = {
      shareToken,
      timetableId: sharedScheduleData.timetableId,
      contributor: {
        name: contributor?.name,
        email: contributor?.email,
        ipAddress: req.ip || "unknown"
      },
      contributions,
      status: "pending",
      submittedAt: admin.firestore.Timestamp.now()
    };

    await contributionRef.set(contributionData);

    res.status(201).json({
      success: true,
      message: "일정 기여가 제출되었습니다. 시간표 소유자의 승인을 기다리고 있습니다.",
      data: { contributionId: contributionRef.id }
    });
  } catch (error) {
    console.error("일정 기여 오류:", error);
    res.status(500).json({ success: false, error: "서버 오류가 발생했습니다." });
  }
});

/**
 * 기여 데이터 승인/거부
 */
// 자동 자습 시간 재계산 함수
const recalculateAutoFillSlots = (
  detailedSchedule: any,
  basicSchedule: any,
  autoFillSettings: any,
  dayOfWeek: string
) => {
  // 방어 코드: basicSchedule 구조 검증
  if (!basicSchedule || !basicSchedule.dailySchedules) {
    console.warn(`[recalculateAutoFillSlots] 기본 스케줄 구조가 없음: ${dayOfWeek}`, {
      basicSchedule: !!basicSchedule,
      dailySchedules: basicSchedule?.dailySchedules
    });
    return detailedSchedule;
  }

  // 방어 코드: autoFillSettings 검증
  if (!autoFillSettings || !autoFillSettings.enabled || !autoFillSettings.fillEmptySlots) {
    return detailedSchedule;
  }

  const daySchedule = basicSchedule.dailySchedules[dayOfWeek];
  if (!daySchedule || !daySchedule.isActive) {
    return detailedSchedule;
  }

  const existingSlots = detailedSchedule[dayOfWeek]?.timeSlots || [];
  const manualSlots = existingSlots.filter((slot: any) => !slot.isAutoGenerated);

  // 시간대 계산
  const arrivalTime = parseInt(daySchedule.arrivalTime.replace(":", ""));
  const departureTime = parseInt(daySchedule.departureTime.replace(":", ""));
  const interval = basicSchedule.timeSlotInterval || 60; // 분 단위

  const autoSlots: any[] = [];
  let currentTime = arrivalTime;

  while (currentTime < departureTime) {
    const endTime = Math.min(currentTime + Math.floor(interval / 60) * 100 + (interval % 60), departureTime);
    const startTimeStr = `${Math.floor(currentTime / 100).toString().padStart(2, "0")}:${(currentTime % 100).toString().padStart(2, "0")}`;
    const endTimeStr = `${Math.floor(endTime / 100).toString().padStart(2, "0")}:${(endTime % 100).toString().padStart(2, "0")}`;

    // 수동 슬롯과 충돌 확인
    const hasConflict = manualSlots.some((slot: any) => {
      const slotStart = parseInt(slot.startTime.replace(":", ""));
      const slotEnd = parseInt(slot.endTime.replace(":", ""));
      return (currentTime < slotEnd && endTime > slotStart);
    });

    if (!hasConflict) {
      autoSlots.push({
        id: `auto_${dayOfWeek}_${currentTime}`,
        startTime: startTimeStr,
        endTime: endTimeStr,
        subject: autoFillSettings.defaultSubject || "자습",
        type: "self_study",
        isAutoGenerated: true,
        color: "#9E9E9E"
      });
    }

    currentTime = endTime;
    if (currentTime % 100 >= 60) {
      currentTime = currentTime - (currentTime % 100) + 100;
    }
  }

  return {
    ...detailedSchedule,
    [dayOfWeek]: {
      timeSlots: [...manualSlots, ...autoSlots]
    }
  };
};

/**
 * 제출된 편집 상태 승인/거부
 */
export const processEditSubmission = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { editStateId, action, rejectionReason } = data; // action: 'approve' | 'reject'

  if (!editStateId || !["approve", "reject"].includes(action)) {
    throw new functions.https.HttpsError("invalid-argument", "올바른 처리 액션을 선택해주세요.");
  }

  try {
    const db = admin.firestore();
    const editStateRef = db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_states")
      .doc(editStateId);

    const editStateDoc = await editStateRef.get();
    if (!editStateDoc.exists) {
      throw new functions.https.HttpsError("not-found", "편집 상태를 찾을 수 없습니다.");
    }

    const editStateData = editStateDoc.data() as any;

    if (editStateData.status !== "submitted") {
      throw new functions.https.HttpsError("failed-precondition", "제출된 편집만 처리할 수 있습니다.");
    }

    const updateData: any = {
      status: action === "approve" ? "approved" : "rejected",
      reviewedAt: admin.firestore.Timestamp.now(),
      reviewedBy: userId
    };

    if (action === "reject" && rejectionReason) {
      updateData.rejectionReason = rejectionReason;
    }

    // 승인된 경우 시간표에 적용
    if (action === "approve") {
      const timetableRef = db
        .collection("users")
        .doc(userId)
        .collection("student_timetables")
        .doc(editStateData.timetableId);

      const timetableDoc = await timetableRef.get();
      if (timetableDoc.exists) {
        // 현재 편집 상태의 시간표를 원본에 적용
        const newVersion = admin.firestore.Timestamp.now().toMillis().toString();

        const updateTimetableData: any = {
          detailedSchedule: editStateData.currentTimetable.detailedSchedule,
          version: newVersion,
          lastUpdatedAt: admin.firestore.Timestamp.now(),
          lastUpdatedBy: "student_edit",
          updatedAt: admin.firestore.Timestamp.now(),
          pendingSubmission: false,
          pendingSubmissionId: null
        };

        // 기본 스케줄 변경사항이 있으면 반영 (실제 dailySchedules 구조 반영)
        if (editStateData.changes?.basicScheduleChanges) {
          updateTimetableData.basicSchedule = editStateData.currentTimetable.basicSchedule;
          
          // 버전 관리 업데이트 (기본 스케줄 변경 시)
          updateTimetableData.basicScheduleVersion = newVersion;
          updateTimetableData.basicScheduleLastUpdatedAt = admin.firestore.Timestamp.now();
          updateTimetableData.basicScheduleLastUpdatedBy = "student_edit";
        }

        await timetableRef.update(updateTimetableData);

        updateData.status = "applied";
        updateData.appliedAt = admin.firestore.Timestamp.now();
      }
    } else {
      // 거부된 경우 원본 시간표의 대기 상태 해제
      await db
        .collection("users")
        .doc(userId)
        .collection("student_timetables")
        .doc(editStateData.timetableId)
        .update({
          pendingSubmission: false,
          pendingSubmissionId: null,
          updatedAt: admin.firestore.Timestamp.now()
        });
    }

    await editStateRef.update(updateData);

    return {
      success: true,
      message: action === "approve" ? "편집 내용이 승인되어 시간표에 적용되었습니다." : "편집 내용이 거부되었습니다."
    };
  } catch (error) {
    console.error("편집 제출 처리 오류:", error);

    if (error instanceof functions.https.HttpsError) {
      throw error;
    }

    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 제출 대기 중인 편집 상태 목록 조회
 */
export const getPendingEditSubmissions = functions.https.onCall(async (_data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;

  try {
    const db = admin.firestore();

    // 제출된 편집 상태들 조회
    const editStatesSnapshot = await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_states")
      .where("status", "==", "submitted")
      .orderBy("submittedAt", "desc")
      .get();

    const pendingSubmissions = editStatesSnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      submittedAt: doc.data().submittedAt?.toDate().toISOString(),
      createdAt: doc.data().createdAt?.toDate().toISOString(),
      updatedAt: doc.data().updatedAt?.toDate().toISOString(),
      expiresAt: doc.data().expiresAt?.toDate().toISOString()
    }));

    return {
      success: true,
      data: pendingSubmissions
    };
  } catch (error) {
    console.error("대기 중인 편집 제출 조회 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

export const processContribution = onCall(async (request) => {
  const { data, auth } = request;
  
  if (!auth) {
    throw new HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = auth.uid;
  const { contributionId, action, rejectionReason } = data; // action: 'approve' | 'reject'

  if (!contributionId || !["approve", "reject"].includes(action)) {
    throw new HttpsError("invalid-argument", "올바른 처리 액션을 선택해주세요.");
  }

  try {
    const db = admin.firestore();
    
    console.log("processContribution 호출됨:", { contributionId, action, userId });
    
    // 1. 먼저 현재 사용자의 컬렉션에서 찾기 시도
    let contributionDoc = null;
    let contributionData = null;
    
    try {
      const userContributionRef = db
        .collection("users")
        .doc(userId)
        .collection("schedule_contributions")
        .doc(contributionId);
      
      const userContributionDoc = await userContributionRef.get();
      
      if (userContributionDoc.exists) {
        contributionDoc = userContributionDoc;
        contributionData = userContributionDoc.data() as any;
        console.log("현재 사용자 컬렉션에서 찾음:", { 
          id: contributionData.id, 
          studentId: contributionData.studentId,
          status: contributionData.status 
        });
      }
    } catch (userError) {
      console.log("현재 사용자 컬렉션에서 찾을 수 없음:", userError);
    }
    
    // 2. 현재 사용자 컬렉션에서 찾지 못했다면 collectionGroup으로 시도
    if (!contributionDoc) {
      try {
        const contributionQuery = await db
          .collectionGroup("schedule_contributions")
          .where("id", "==", contributionId)
          .limit(1)
          .get();

        console.log("collectionGroup 쿼리 결과:", { 
          size: contributionQuery.size, 
          empty: contributionQuery.empty,
          docs: contributionQuery.docs.map(doc => ({ id: doc.id, data: doc.data() }))
        });

        if (!contributionQuery.empty) {
          contributionDoc = contributionQuery.docs[0];
          contributionData = contributionDoc.data() as any;
          console.log("collectionGroup에서 찾은 기여 데이터:", { 
            id: contributionData.id, 
            studentId: contributionData.studentId,
            status: contributionData.status 
          });
        }
      } catch (groupError) {
        console.log("collectionGroup 쿼리 실패:", groupError);
      }
    }
    
    if (!contributionDoc || !contributionData) {
      console.log("기여 데이터를 찾을 수 없음:", contributionId);
      throw new HttpsError("not-found", "기여 데이터를 찾을 수 없습니다.");
    }

    // 2. 이제 올바른 사용자 ID로 문서 참조 생성 (나중에 업데이트할 때 사용)
    const contributionRef = db
      .collection("users")
      .doc(contributionData.studentId)
      .collection("schedule_contributions")
      .doc(contributionId);

    if (contributionData.status !== "pending") {
      throw new HttpsError("failed-precondition", "이미 처리된 기여입니다.");
    }

    const updateData: any = {
      status: action === "approve" ? "approved" : "rejected",
      processedAt: admin.firestore.Timestamp.now(),
      processedBy: userId
    };

    // 거부 사유 추가
    if (action === "reject" && rejectionReason) {
      updateData.rejectionReason = rejectionReason;
    }

    // 승인된 경우 시간표에 적용
    if (action === "approve") {
      // 학생 시간표 편집 타입 처리
      if (contributionData.contributionType === "student_timetable_edit") {
        const timetableRef = db
          .collection("users")
          .doc(contributionData.studentId)
          .collection("student_timetables")
          .doc(contributionData.originalTimetableId);

        const timetableDoc = await timetableRef.get();
        if (timetableDoc.exists) {
          const currentTimetableData = timetableDoc.data() as any;

          // 버전 검증 (version 필드가 없거나 undefined인 경우 고려)
          const currentVersion = currentTimetableData.version || "1.0";
          const originalVersion = contributionData.originalVersion || "1.0";
          
          if (currentVersion !== originalVersion) {
            throw new HttpsError(
              "failed-precondition",
              "시간표가 다른 사용자에 의해 수정되었습니다. 최신 버전을 확인 후 다시 처리해주세요."
            );
          }

          // 제안된 시간표 적용
          let updatedSchedule = { ...contributionData.proposedTimetable.detailedSchedule };

          // 각 요일별로 자동 자습 시간 재계산
          const daysOfWeek = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];

          // proposedTimetable에 이미 완전한 구조가 포함되어 있으므로 직접 사용 (더 안전함)
          const timetableBasicSchedule = contributionData.proposedTimetable.basicSchedule ||
                                         currentTimetableData.basicSchedule;
          const timetableAutoFillSettings = contributionData.proposedTimetable.autoFillSettings ||
                                            currentTimetableData.autoFillSettings;

          for (const day of daysOfWeek) {
            if (updatedSchedule[day]) {
              updatedSchedule = recalculateAutoFillSlots(
                updatedSchedule,
                timetableBasicSchedule, // 이제 항상 존재하는 구조
                timetableAutoFillSettings, // 이제 항상 존재하는 구조
                day
              );
            }
          }

          // 버전 업데이트
          const newVersion = admin.firestore.Timestamp.now().toMillis().toString();

          const timetableUpdateData: any = {
            detailedSchedule: updatedSchedule,
            version: newVersion,
            lastUpdatedAt: admin.firestore.Timestamp.now(),
            lastUpdatedBy: "student",
            updatedAt: admin.firestore.Timestamp.now()
          };

          // 기본 스케줄 변경사항이 있으면 반영
          if (contributionData.proposedTimetable.hasBasicScheduleChanges &&
              contributionData.proposedTimetable.basicSchedule) {
            timetableUpdateData.basicSchedule = contributionData.proposedTimetable.basicSchedule;
            timetableUpdateData.basicScheduleVersion = newVersion;
            timetableUpdateData.basicScheduleLastUpdatedAt = admin.firestore.Timestamp.now();
            timetableUpdateData.basicScheduleLastUpdatedBy = "student_edit";
          }

          await timetableRef.update(timetableUpdateData);

          updateData.status = "applied";
          updateData.appliedAt = admin.firestore.Timestamp.now();
        }
      } else {
        // 기존 일반 기여 처리 로직
        const timetableRef = db
          .collection("users")
          .doc(userId)
          .collection("timetables")
          .doc(contributionData.timetableId);

        const timetableDoc = await timetableRef.get();
        if (timetableDoc.exists) {
          const timetableData = timetableDoc.data();
          const updatedSchedule = { ...timetableData?.detailedSchedule };

          // 기여된 일정을 시간표에 반영
          for (const contribution of contributionData.contributions) {
            const dayOfWeek = contribution.dayOfWeek;
            if (!updatedSchedule[dayOfWeek]) {
              updatedSchedule[dayOfWeek] = { timeSlots: [] };
            }

            // 기존 자동생성 자습시간 제거 후 새 일정 추가
            const existingSlots = updatedSchedule[dayOfWeek].timeSlots.filter(
              (slot: any) => !slot.isAutoGenerated
            );
            updatedSchedule[dayOfWeek].timeSlots = [
              ...existingSlots,
              ...contribution.timeSlots
            ];
          }

          await timetableRef.update({
            detailedSchedule: updatedSchedule,
            updatedAt: admin.firestore.Timestamp.now()
          });

          updateData.status = "applied";
          updateData.appliedAt = admin.firestore.Timestamp.now();
        }
      }
    }

    await contributionRef.update(updateData);

    return {
      success: true,
      message: action === "approve" ? "기여가 승인되어 시간표에 적용되었습니다." : "기여가 거부되었습니다."
    };
  } catch (error) {
    console.error("기여 처리 오류:", error);
    throw new HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 공유 링크 관리 (비활성화/삭제)
 */
export const manageShareLink = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { shareId, action } = data; // action: 'disable' | 'delete'

  if (!shareId || !["disable", "delete"].includes(action)) {
    throw new functions.https.HttpsError("invalid-argument", "올바른 관리 액션을 선택해주세요.");
  }

  try {
    const db = admin.firestore();
    const shareRef = db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .doc(shareId);

    const shareDoc = await shareRef.get();
    if (!shareDoc.exists) {
      throw new functions.https.HttpsError("not-found", "공유 링크를 찾을 수 없습니다.");
    }

    if (action === "delete") {
      await shareRef.delete();
    } else {
      await shareRef.update({
        "linkSettings.isActive": false,
        "updatedAt": admin.firestore.Timestamp.now()
      });
    }

    return {
      success: true,
      message: action === "delete" ? "공유 링크가 삭제되었습니다." : "공유 링크가 비활성화되었습니다."
    };
  } catch (error) {
    console.error("공유 링크 관리 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

// ==================== 편집 잠금 관리 함수들 ====================

/**
 * 시간표 편집 잠금 생성
 */
export const createTimetableEditLock = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { timetableId, studentId, shareToken, lockType = "student_edit", expiresInMinutes = 60 } = data;

  if (!timetableId || !studentId) {
    throw new functions.https.HttpsError("invalid-argument", "필수 데이터가 누락되었습니다.");
  }

  try {
    const db = admin.firestore();
    const lockId = uuidv4();

    // 기존 활성 잠금 확인
    const existingLockQuery = await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_locks")
      .where("timetableId", "==", timetableId)
      .where("studentId", "==", studentId)
      .where("isActive", "==", true)
      .limit(1)
      .get();

    if (!existingLockQuery.empty) {
      const existingLock = existingLockQuery.docs[0].data() as TimetableEditLock;

      // 만료 시간 확인
      if (existingLock.expiresAt && existingLock.expiresAt.toDate() > new Date()) {
        throw new functions.https.HttpsError("already-exists", "이미 편집 중인 시간표입니다.");
      }

      // 만료된 잠금 비활성화
      await existingLockQuery.docs[0].ref.update({ isActive: false });
    }

    // 새 잠금 생성
    const expiresAt = new Date();
    expiresAt.setMinutes(expiresAt.getMinutes() + expiresInMinutes);

    const lockData: TimetableEditLock = {
      id: lockId,
      timetableId,
      studentId,
      shareToken: shareToken || "",
      lockedBy: lockType === "admin_edit" ? "admin" : "student",
      lockType,
      lockedAt: admin.firestore.Timestamp.now(),
      expiresAt: admin.firestore.Timestamp.fromDate(expiresAt),
      isActive: true,
      metadata: {
        editStartedAt: admin.firestore.Timestamp.now(),
        lastActivityAt: admin.firestore.Timestamp.now()
      }
    };

    await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_locks")
      .doc(lockId)
      .set(lockData);

    return {
      success: true,
      data: {
        lockId,
        expiresAt: expiresAt.toISOString()
      }
    };
  } catch (error) {
    console.error("편집 잠금 생성 오류:", error);

    if (error instanceof functions.https.HttpsError) {
      throw error;
    }

    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 시간표 편집 잠금 해제
 */
export const releaseTimetableEditLock = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { lockId } = data;

  if (!lockId) {
    throw new functions.https.HttpsError("invalid-argument", "잠금 ID가 필요합니다.");
  }

  try {
    const db = admin.firestore();

    const lockRef = db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_locks")
      .doc(lockId);

    const lockDoc = await lockRef.get();

    if (!lockDoc.exists) {
      throw new functions.https.HttpsError("not-found", "편집 잠금을 찾을 수 없습니다.");
    }

    await lockRef.update({
      isActive: false,
      releasedAt: admin.firestore.Timestamp.now()
    });

    return {
      success: true,
      message: "편집 잠금이 해제되었습니다."
    };
  } catch (error) {
    console.error("편집 잠금 해제 오류:", error);

    if (error instanceof functions.https.HttpsError) {
      throw error;
    }

    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 시간표 편집 잠금 상태 조회
 */
export const getTimetableEditLock = functions.https.onCall(async (data: any, context: any) => {
  if (!context.auth) {
    throw new functions.https.HttpsError("unauthenticated", "인증이 필요합니다.");
  }

  const userId = context.auth.uid;
  const { timetableId, studentId } = data;

  if (!timetableId || !studentId) {
    throw new functions.https.HttpsError("invalid-argument", "필수 데이터가 누락되었습니다.");
  }

  try {
    const db = admin.firestore();

    const lockQuery = await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_locks")
      .where("timetableId", "==", timetableId)
      .where("studentId", "==", studentId)
      .where("isActive", "==", true)
      .limit(1)
      .get();

    if (lockQuery.empty) {
      return {
        success: true,
        data: {
          isLocked: false,
          lockData: null
        }
      };
    }

    const lockDoc = lockQuery.docs[0];
    const lockData = { id: lockDoc.id, ...lockDoc.data() } as TimetableEditLock;

    // 만료 시간 확인
    if (lockData.expiresAt && lockData.expiresAt.toDate() <= new Date()) {
      // 만료된 잠금 비활성화
      await lockDoc.ref.update({ isActive: false });

      return {
        success: true,
        data: {
          isLocked: false,
          lockData: null
        }
      };
    }

    return {
      success: true,
      data: {
        isLocked: true,
        lockData: {
          ...lockData,
          lockedAt: lockData.lockedAt.toDate().toISOString(),
          expiresAt: lockData.expiresAt?.toDate().toISOString() || null
        }
      }
    };
  } catch (error) {
    console.error("편집 잠금 상태 조회 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

/**
 * 편집 잠금 활동 업데이트 (하트비트)
 */
export const updateEditLockActivity = functions.https.onCall(async (data: any) => {
  const { shareToken } = data;

  if (!shareToken) {
    throw new functions.https.HttpsError("invalid-argument", "공유 토큰이 필요합니다.");
  }

  try {
    const db = admin.firestore();

    // 공유 토큰으로 활성 잠금 조회
    const lockQuery = await db
      .collectionGroup("timetable_edit_locks")
      .where("shareToken", "==", shareToken)
      .where("isActive", "==", true)
      .limit(1)
      .get();

    if (!lockQuery.empty) {
      const lockDoc = lockQuery.docs[0];

      await lockDoc.ref.update({
        "metadata.lastActivityAt": admin.firestore.Timestamp.now()
      });
    }

    return {
      success: true,
      message: "활동 상태가 업데이트되었습니다."
    };
  } catch (error) {
    console.error("편집 잠금 활동 업데이트 오류:", error);
    throw new functions.https.HttpsError("internal", "서버 오류가 발생했습니다.");
  }
});

// ==================== 편집 링크 관리 함수들 ====================

/**
 * 학생별 편집 링크 목록 조회
 */
export const getStudentEditLinks = functions.https.onRequest(async (req, res) => {
  console.log("=== getStudentEditLinks 호출됨 ===");
  console.log("Request Headers:", req.headers);
  console.log("Request Query:", req.query);
  console.log("Request Method:", req.method);

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "GET") {
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    console.log("함수 실행 시작");
    // Authorization 헤더에서 토큰 추출
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      res.status(401).json({ error: { message: "인증이 필요합니다.", status: "UNAUTHENTICATED" } });
      return;
    }

    const idToken = authHeader.split("Bearer ")[1];
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    const userId = decodedToken.uid;

    const { studentId, includeInactive = false } = req.query;

    if (!studentId) {
      res.status(400).json({ error: { message: "학생 ID가 필요합니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    const db = admin.firestore();
    
    // 1. studentId로 timetableId 찾기
    console.log("학생의 시간표 ID 조회 중...", { userId, studentId });
    const studentTimetablesQuery = await db
      .collection("users")
      .doc(userId)
      .collection("student_timetables")
      .where("studentId", "==", studentId)
      .where("isActive", "==", true)
      .get();
    
    if (studentTimetablesQuery.empty) {
      console.log("학생의 활성 시간표를 찾을 수 없음");
      res.json({
        success: true,
        data: []
      });
      return;
    }
    
    // 2. 찾은 timetableId들로 shared_schedules 검색
    const timetableIds = studentTimetablesQuery.docs.map(doc => doc.id);
    console.log("찾은 timetableId들:", timetableIds);
    
    let query = db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .where("timetableId", "in", timetableIds);

    if (!includeInactive) {
      query = query.where("linkSettings.isActive", "==", true);
    }

    console.log("쿼리 실행 중...", { userId, studentId, timetableIds, includeInactive });
    const snapshot = await query.get();
    console.log("쿼리 결과:", { size: snapshot.size, empty: snapshot.empty });

    const links = snapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        shareToken: data.shareToken,
        timetableId: data.timetableId,
        title: data.title,
        description: data.description,
        isActive: data.linkSettings.isActive,
        createdAt: data.linkSettings.createdAt,
        lastUsedAt: data.linkSettings.lastUsedAt,
        usageCount: data.linkSettings.usageCount,
        expiresAt: data.linkSettings.expiresAt,
        deactivatedAt: data.linkSettings.deactivatedAt,
        permissions: data.permissions,
        accessSettings: data.accessSettings
      };
    });

    // 클라이언트에서 생성일 기준으로 정렬 (최신순)
    links.sort((a, b) => {
      const aTime = a.createdAt?.toMillis?.() || 0;
      const bTime = b.createdAt?.toMillis?.() || 0;
      return bTime - aTime; // 내림차순 (최신순)
    });

    console.log("최종 링크 데이터:", { count: links.length, links: links.map(l => ({ id: l.id, shareToken: l.shareToken, isActive: l.isActive })) });

    res.json({
      success: true,
      data: links
    });
  } catch (error: any) {
    console.error("편집 링크 목록 조회 오류:", error);
    console.error("오류 상세:", {
      message: error?.message,
      stack: error?.stack,
      name: error?.name
    });
    res.status(500).json({ 
      error: { 
        message: "서버 오류가 발생했습니다.", 
        status: "INTERNAL" 
      } 
    });
  }
});

/**
 * 편집 링크 비활성화
 */
export const deactivateEditLink = functions.https.onRequest(async (req, res) => {
  console.log("=== deactivateEditLink 호출됨 ===");

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "POST") {
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    // Authorization 헤더에서 토큰 추출
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      res.status(401).json({ error: { message: "인증이 필요합니다.", status: "UNAUTHENTICATED" } });
      return;
    }

    const idToken = authHeader.split("Bearer ")[1];
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    const userId = decodedToken.uid;

    const { shareToken } = req.body;

    if (!shareToken) {
      res.status(400).json({ error: { message: "공유 토큰이 필요합니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    const db = admin.firestore();

    // 링크 조회 및 비활성화
    const linkQuery = await db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (linkQuery.empty) {
      res.status(404).json({ error: { message: "링크를 찾을 수 없습니다.", status: "NOT_FOUND" } });
      return;
    }

    const linkDoc = linkQuery.docs[0];
    const linkData = linkDoc.data();

    if (!linkData.linkSettings.isActive) {
      res.status(400).json({ error: { message: "이미 비활성화된 링크입니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    // 링크 비활성화
    await linkDoc.ref.update({
      "linkSettings.isActive": false,
      "linkSettings.deactivatedAt": admin.firestore.Timestamp.now(),
      "updatedAt": admin.firestore.Timestamp.now()
    });

    // 관련 편집 상태도 비활성화
    const editStatesQuery = await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_states")
      .where("shareToken", "==", shareToken)
      .where("status", "==", "active")
      .get();

    const batch = db.batch();
    editStatesQuery.docs.forEach(doc => {
      batch.update(doc.ref, {
        status: "expired",
        expiredAt: admin.firestore.Timestamp.now()
      });
    });

    await batch.commit();

    // 로그 기록
    await db.collection("users").doc(userId).collection("edit_link_logs").add({
      shareToken,
      action: "deactivated",
      timestamp: admin.firestore.Timestamp.now(),
      details: "링크가 비활성화되었습니다.",
      userId,
      userName: decodedToken.name || decodedToken.email
    });

    res.json({
      success: true,
      message: "링크가 비활성화되었습니다."
    });
  } catch (error) {
    console.error("링크 비활성화 오류:", error);
    res.status(500).json({ 
      error: { 
        message: "서버 오류가 발생했습니다.", 
        status: "INTERNAL" 
      } 
    });
  }
});

/**
 * 편집 링크 재활성화
 */
export const activateEditLink = functions.https.onRequest(async (req, res) => {
  console.log("=== activateEditLink 호출됨 ===");

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "POST") {
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    // Authorization 헤더에서 토큰 추출
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      res.status(401).json({ error: { message: "인증이 필요합니다.", status: "UNAUTHENTICATED" } });
      return;
    }

    const idToken = authHeader.split("Bearer ")[1];
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    const userId = decodedToken.uid;

    const { shareToken } = req.body;

    if (!shareToken) {
      res.status(400).json({ error: { message: "공유 토큰이 필요합니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    const db = admin.firestore();

    // 링크 조회 및 재활성화
    const linkQuery = await db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (linkQuery.empty) {
      res.status(404).json({ error: { message: "링크를 찾을 수 없습니다.", status: "NOT_FOUND" } });
      return;
    }

    const linkDoc = linkQuery.docs[0];
    const linkData = linkDoc.data();

    if (linkData.linkSettings.isActive) {
      res.status(400).json({ error: { message: "이미 활성화된 링크입니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    // 만료 확인
    if (linkData.linkSettings.expiresAt && linkData.linkSettings.expiresAt.toDate() < new Date()) {
      res.status(400).json({ error: { message: "만료된 링크는 재활성화할 수 없습니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    // 링크 재활성화
    await linkDoc.ref.update({
      "linkSettings.isActive": true,
      "linkSettings.deactivatedAt": admin.firestore.FieldValue.delete(),
      "updatedAt": admin.firestore.Timestamp.now()
    });

    // 로그 기록
    await db.collection("users").doc(userId).collection("edit_link_logs").add({
      shareToken,
      action: "activated",
      timestamp: admin.firestore.Timestamp.now(),
      details: "링크가 재활성화되었습니다.",
      userId,
      userName: decodedToken.name || decodedToken.email
    });

    res.json({
      success: true,
      message: "링크가 재활성화되었습니다."
    });
  } catch (error) {
    console.error("링크 재활성화 오류:", error);
    res.status(500).json({ 
      error: { 
        message: "서버 오류가 발생했습니다.", 
        status: "INTERNAL" 
      } 
    });
  }
});

/**
 * 편집 링크 삭제
 */
export const deleteEditLink = functions.https.onRequest(async (req, res) => {
  console.log("=== deleteEditLink 호출됨 ===");

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "POST") {
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    // Authorization 헤더에서 토큰 추출
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      res.status(401).json({ error: { message: "인증이 필요합니다.", status: "UNAUTHENTICATED" } });
      return;
    }

    const idToken = authHeader.split("Bearer ")[1];
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    const userId = decodedToken.uid;

    const { shareToken } = req.body;

    if (!shareToken) {
      res.status(400).json({ error: { message: "공유 토큰이 필요합니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    const db = admin.firestore();

    // 링크 조회
    const linkQuery = await db
      .collection("users")
      .doc(userId)
      .collection("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (linkQuery.empty) {
      res.status(404).json({ error: { message: "링크를 찾을 수 없습니다.", status: "NOT_FOUND" } });
      return;
    }

    const linkDoc = linkQuery.docs[0];

    // 관련 데이터 정리
    const batch = db.batch();

    // 링크 삭제
    batch.delete(linkDoc.ref);

    // 관련 편집 상태 삭제
    const editStatesQuery = await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_states")
      .where("shareToken", "==", shareToken)
      .get();

    editStatesQuery.docs.forEach(doc => {
      batch.delete(doc.ref);
    });

    // 관련 편집 잠금 삭제
    const editLocksQuery = await db
      .collection("users")
      .doc(userId)
      .collection("timetable_edit_locks")
      .where("shareToken", "==", shareToken)
      .get();

    editLocksQuery.docs.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();

    // 로그 기록
    await db.collection("users").doc(userId).collection("edit_link_logs").add({
      shareToken,
      action: "deleted",
      timestamp: admin.firestore.Timestamp.now(),
      details: "링크가 삭제되었습니다.",
      userId,
      userName: decodedToken.name || decodedToken.email
    });

    res.json({
      success: true,
      message: "링크가 삭제되었습니다."
    });
  } catch (error) {
    console.error("링크 삭제 오류:", error);
    res.status(500).json({ 
      error: { 
        message: "서버 오류가 발생했습니다.", 
        status: "INTERNAL" 
      } 
    });
  }
});

/**
 * 편집 링크 로그 조회
 */
export const getEditLinkLogs = functions.https.onRequest(async (req, res) => {
  console.log("=== getEditLinkLogs 호출됨 ===");

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "GET, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "GET") {
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    // Authorization 헤더에서 토큰 추출
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      res.status(401).json({ error: { message: "인증이 필요합니다.", status: "UNAUTHENTICATED" } });
      return;
    }

    const idToken = authHeader.split("Bearer ")[1];
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    const userId = decodedToken.uid;

    const { shareToken, limit = 50 } = req.query;

    const db = admin.firestore();
    const baseQuery = db
      .collection("users")
      .doc(userId)
      .collection("edit_link_logs");

    const query = shareToken ?
      baseQuery.where("shareToken", "==", shareToken).orderBy("timestamp", "desc").limit(Number(limit)) :
      baseQuery.orderBy("timestamp", "desc").limit(Number(limit));

    const snapshot = await query.get();

    const logs = snapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        shareToken: data.shareToken,
        action: data.action,
        timestamp: data.timestamp,
        details: data.details,
        userId: data.userId,
        userName: data.userName,
        ipAddress: data.ipAddress,
        userAgent: data.userAgent
      };
    });

    res.json({
      success: true,
      data: logs
    });
  } catch (error) {
    console.error("링크 로그 조회 오류:", error);
    res.status(500).json({ 
      error: { 
        message: "서버 오류가 발생했습니다.", 
        status: "INTERNAL" 
      } 
    });
  }
});

/**
 * 편집 링크 사용 기록
 */
export const recordEditLinkUsage = functions.https.onRequest(async (req, res) => {
  console.log("=== recordEditLinkUsage 호출됨 ===");

  // CORS 설정
  res.set("Access-Control-Allow-Origin", "*");
  res.set("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") {
    res.status(204).send("");
    return;
  }

  if (req.method !== "POST") {
    res.status(405).json({ error: { message: "Method not allowed", status: "INVALID_ARGUMENT" } });
    return;
  }

  try {
    const { shareToken, action, details, ipAddress, userAgent } = req.body;

    if (!shareToken || !action) {
      res.status(400).json({ error: { message: "공유 토큰과 액션이 필요합니다.", status: "INVALID_ARGUMENT" } });
      return;
    }

    const db = admin.firestore();

    // 링크 조회하여 userId 찾기
    const linkQuery = await db
      .collectionGroup("shared_schedules")
      .where("shareToken", "==", shareToken)
      .limit(1)
      .get();

    if (linkQuery.empty) {
      res.status(404).json({ error: { message: "유효하지 않은 링크입니다.", status: "NOT_FOUND" } });
      return;
    }

    const linkDoc = linkQuery.docs[0];
    const userId = linkDoc.ref.parent.parent?.id;

    if (!userId) {
      res.status(500).json({ error: { message: "사용자 ID를 찾을 수 없습니다.", status: "INTERNAL" } });
      return;
    }

    // 사용 기록 로그 생성
    await db.collection("users").doc(userId).collection("edit_link_logs").add({
      shareToken,
      action,
      timestamp: admin.firestore.Timestamp.now(),
      details: details || `${action} 액션이 수행되었습니다.`,
      ipAddress: ipAddress || req.ip,
      userAgent: userAgent || req.get("User-Agent")
    });

    // 링크 사용 통계 업데이트
    if (action === "accessed") {
      await linkDoc.ref.update({
        "linkSettings.lastUsedAt": admin.firestore.Timestamp.now(),
        "linkSettings.usageCount": admin.firestore.FieldValue.increment(1),
        "updatedAt": admin.firestore.Timestamp.now()
      });
    }

    res.json({
      success: true,
      message: "사용 기록이 저장되었습니다."
    });
  } catch (error) {
    console.error("사용 기록 저장 오류:", error);
    res.status(500).json({ 
      error: { 
        message: "서버 오류가 발생했습니다.", 
        status: "INTERNAL" 
      } 
    });
  }
});
