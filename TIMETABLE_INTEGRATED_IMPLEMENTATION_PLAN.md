# 시간표 페이지 - 학생별 시간표 관리 통합 구현 계획서

## 📋 개요

TimeTable.tsx 페이지에 학생 목록(왼쪽)과 선택된 학생의 고급 2레이어 시간표(오른쪽)를 표시하는 기능을 구현하기 위한 통합 계획서입니다. DATABASE_DESIGN.md의 모든 요구사항과 사용자별 데이터 격리 아키텍처를 완벽히 반영합니다.

### 목표
- **왼쪽 패널**: 현재 사용자가 관리하는 학생 목록 표시 및 관리
- **오른쪽 패널**: 선택된 학생의 고급 2레이어 시간표 표시 및 편집
- **고급 시간표**: 등원/하원 + 세부일정 분리, 자동 자습시간 채우기, 링크 공유 기능
- **완전한 데이터 격리**: Google 인증 기반 사용자별 데이터 분리

## 🗄️ 통합 데이터베이스 구조

### 1. 전체 컬렉션 구조 (DATABASE_DESIGN.md 기준)

```
users/{userId} (Google 인증 기반)
├── (사용자 기본 정보)
├── students/                    // 학생 정보 관리
├── student_timetables/          // 학생별 시간표 (신규 추가)
├── timetables/                  // 개인/템플릿 시간표
├── shared_schedules/            // 시간표 공유 링크 관리
├── schedule_contributions/      // 외부 일정 기여 수집
├── seats/                       // 좌석 정보
├── seat_assignments/            // 좌석 배정
├── seat_layouts/                // 좌석 배치도
├── class_sections/              // 학급 정보
├── attendance_summaries/        // 출석 요약
└── settings/                    // 사용자 설정
```

### 2. 학생별 시간표 데이터 모델 (핵심)

```typescript
// users/{userId}/student_timetables/{timetableId}
interface StudentTimetable {
  id: string;                          // 문서 ID
  studentId: string;                   // 해당 학생 ID (students 컬렉션 참조)
  studentName: string;                 // 학생 이름 (캐시용)

  // 시간표 기본 정보
  name: string;                        // 시간표 이름 (예: "1학기 시간표")
  description?: string;                // 시간표 설명

  // 1차 레이어: 등원/하원 기본 틀 (DATABASE_DESIGN.md 기준)
  basicSchedule: {
    arrivalTime: string;               // 등원 시간 "09:00"
    departureTime: string;             // 하원 시간 "18:00"
    daysOfWeek: DayOfWeek[];          // 활성 요일 ["monday", "tuesday", ...]
    timeSlotInterval: number;          // 시간 단위 (분) 기본값: 30
  };

  // 2차 레이어: 구체적인 일정 (DATABASE_DESIGN.md 기준)
  detailedSchedule: {
    [dayOfWeek: string]: {             // "monday", "tuesday" 등
      timeSlots: {
        startTime: string;             // "10:00"
        endTime: string;               // "11:30"
        subject: string;               // "수학", "영어", "자습"
        type: 'class' | 'self_study'; // 수업/자습 구분
        isAutoGenerated: boolean;      // 자동생성된 자습시간인지
        color?: string;                // 시간표 표시 색상
        teacher?: string;              // 담당 강사
        location?: string;             // 수업 장소
        notes?: string;                // 추가 메모
      }[];
    };
  };

  // 공유 기능 (DATABASE_DESIGN.md 기준)
  isShared: boolean;                   // 공유 활성화 여부
  shareToken?: string;                 // 링크 공유용 고유 토큰
  shareSettings: {
    allowEdit: boolean;                // 외부 편집 허용
    allowView: boolean;                // 외부 조회 허용
    expiresAt?: FirestoreTimestamp;    // 공유 만료일
  };

  // 자동 채우기 설정 (DATABASE_DESIGN.md 기준)
  autoFillSettings: {
    enabled: boolean;                  // 자동 자습시간 채우기 활성화
    defaultSubject: string;            // 기본 자습 과목명 "자습"
    fillEmptySlots: boolean;           // 빈 시간 자동 채우기
  };

  // 상태 관리
  isActive: boolean;                   // 활성 시간표 (학생당 하나만 활성)
  isDefault: boolean;                  // 기본 시간표 여부

  // 메타데이터
  createdAt: FirestoreTimestamp;       // 생성일
  updatedAt: FirestoreTimestamp;       // 수정일
  userId: string;                      // 소유자 사용자 ID (Google Auth UID)
}

type DayOfWeek = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';
```

### 3. 학생 정보 확장 (기존 + 시간표 연동)

```typescript
// users/{userId}/students/{studentId}
interface Student {
  id: string;                      // Firestore 문서 ID
  name: string;                    // 학생 이름
  email: string;                   // 학생 이메일
  grade: string;                   // 학생 학년 (중1, 중2, 중3, 고1, 고2, 고3)
  phone?: string;                  // 학생 전화번호
  parentName?: string;             // 보호자 이름
  parentPhone?: string;            // 보호자 전화번호
  address?: string;                // 주소

  // 시간표 관련 정보 (추가)
  activeTimetableId?: string;      // 현재 활성 시간표 ID
  timetableCount: number;          // 총 시간표 개수

  // 상태 관리
  isActive: boolean;               // 활성 상태
  createdAt: Date;                 // 생성일
  updatedAt: Date;                 // 수정일
  userId: string;                  // 소유자 사용자 ID (Google Auth UID)
}
```

### 4. Firestore 보안 규칙 업데이트

```javascript
// firestore.rules에 추가
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // 사용자별 데이터 - Google 인증 기반 격리
    match /users/{userId} {
      // 사용자는 본인 데이터만 접근 가능
      allow read, write: if request.auth != null &&
        request.auth.uid == userId;

      // 학생 정보 - 해당 사용자만 접근 가능
      match /students/{studentId} {
        allow read, write: if request.auth != null &&
          request.auth.uid == userId;
      }

      // 학생별 시간표 - 해당 사용자만 접근 가능 (신규)
      match /student_timetables/{timetableId} {
        allow read, write: if request.auth != null &&
          request.auth.uid == userId;
      }

      // 시간표 공유 링크 관리 - 본인만 접근 가능
      match /shared_schedules/{scheduleId} {
        allow read, write: if request.auth != null &&
          request.auth.uid == userId;
      }

      // 외부 일정 기여 수집 - 본인만 접근 가능
      match /schedule_contributions/{contributionId} {
        allow read, write: if request.auth != null &&
          request.auth.uid == userId;
      }

      // 기타 모든 하위 컬렉션
      match /{subCollection}/{docId} {
        allow read, write: if request.auth != null &&
          request.auth.uid == userId;
      }
    }

    // 루트 레벨 접근 차단
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
```

## 🔧 백엔드 구현 (Cloud Functions)

### 1. 학생별 시간표 관리 함수

`functions/src/modules/personal/studentTimetableManagement.ts` 생성:

```typescript
/**
 * 학생별 시간표 관리 Cloud Functions
 * DATABASE_DESIGN.md의 고급 시간표 구조 완벽 지원
 */

import { onCall, HttpsError } from "firebase-functions/v2/https";
import { getFirestore, FieldValue } from "firebase-admin/firestore";

const db = getFirestore();

// 학생별 시간표 CRUD
export const createStudentTimetable = onCall(async (request) => {
  // Google 인증 확인
  if (!request.auth) {
    throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
  }

  const userId = request.auth.uid;
  const { studentId, name, basicSchedule, autoFillSettings } = request.data;

  // 새 시간표 생성
  const timetableData = {
    studentId,
    studentName: "", // 학생 정보에서 가져올 예정
    name,
    basicSchedule,
    detailedSchedule: {},
    isShared: false,
    shareSettings: {
      allowEdit: false,
      allowView: false
    },
    autoFillSettings: {
      enabled: true,
      defaultSubject: "자습",
      fillEmptySlots: true,
      ...autoFillSettings
    },
    isActive: false,
    isDefault: false,
    createdAt: FieldValue.serverTimestamp(),
    updatedAt: FieldValue.serverTimestamp(),
    userId
  };

  // Firestore에 저장
  const docRef = await db.collection(`users/${userId}/student_timetables`).add(timetableData);

  return { id: docRef.id, ...timetableData };
});

export const getStudentTimetables = onCall(async (request) => {
  if (!request.auth) {
    throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
  }

  const userId = request.auth.uid;
  const { studentId } = request.data;

  const snapshot = await db
    .collection(`users/${userId}/student_timetables`)
    .where("studentId", "==", studentId)
    .orderBy("createdAt", "desc")
    .get();

  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
});

export const updateStudentTimetable = onCall(async (request) => {
  if (!request.auth) {
    throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
  }

  const userId = request.auth.uid;
  const { timetableId, updates } = request.data;

  const updateData = {
    ...updates,
    updatedAt: FieldValue.serverTimestamp()
  };

  await db.doc(`users/${userId}/student_timetables/${timetableId}`).update(updateData);

  return { success: true };
});

// 자동 자습시간 채우기 (DATABASE_DESIGN.md 기준)
export const autoFillStudentTimetable = onCall(async (request) => {
  if (!request.auth) {
    throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
  }

  const userId = request.auth.uid;
  const { timetableId } = request.data;

  // 시간표 조회
  const timetableDoc = await db.doc(`users/${userId}/student_timetables/${timetableId}`).get();
  if (!timetableDoc.exists) {
    throw new HttpsError("not-found", "시간표를 찾을 수 없습니다.");
  }

  const timetableData = timetableDoc.data();
  const { basicSchedule, detailedSchedule, autoFillSettings } = timetableData;

  // 자동 채우기 로직 구현
  const updatedSchedule = { ...detailedSchedule };

  for (const day of basicSchedule.daysOfWeek) {
    if (!updatedSchedule[day]) {
      updatedSchedule[day] = { timeSlots: [] };
    }

    // 등원 시간부터 하원 시간까지 시간 슬롯 생성
    const startTime = parseTime(basicSchedule.arrivalTime);
    const endTime = parseTime(basicSchedule.departureTime);
    const interval = basicSchedule.timeSlotInterval;

    // 기존 일정이 없는 시간대에 자습 추가
    // ... 자동 채우기 로직 구현
  }

  // 업데이트된 스케줄 저장
  await db.doc(`users/${userId}/student_timetables/${timetableId}`).update({
    detailedSchedule: updatedSchedule,
    updatedAt: FieldValue.serverTimestamp()
  });

  return { success: true, detailedSchedule: updatedSchedule };
});

// 시간표 공유 기능 (DATABASE_DESIGN.md 기준)
export const createStudentTimetableShareLink = onCall(async (request) => {
  if (!request.auth) {
    throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
  }

  const userId = request.auth.uid;
  const { timetableId, shareSettings } = request.data;

  // 고유 공유 토큰 생성
  const shareToken = generateUniqueToken();

  // 시간표에 공유 정보 업데이트
  await db.doc(`users/${userId}/student_timetables/${timetableId}`).update({
    isShared: true,
    shareToken,
    shareSettings: {
      allowEdit: shareSettings.allowEdit || false,
      allowView: shareSettings.allowView || true,
      expiresAt: shareSettings.expiresAt || null
    },
    updatedAt: FieldValue.serverTimestamp()
  });

  // shared_schedules 컬렉션에 공유 정보 저장
  await db.collection(`users/${userId}/shared_schedules`).add({
    shareToken,
    timetableId,
    permissions: {
      canEdit: shareSettings.allowEdit || false,
      canView: shareSettings.allowView || true,
      canComment: false
    },
    accessSettings: {
      requireName: true,
      requireEmail: false
    },
    linkSettings: {
      isActive: true,
      expiresAt: shareSettings.expiresAt || null,
      createdAt: FieldValue.serverTimestamp(),
      usageCount: 0
    },
    createdAt: FieldValue.serverTimestamp(),
    updatedAt: FieldValue.serverTimestamp()
  });

  return { shareToken, shareUrl: `${process.env.BASE_URL}/shared/${shareToken}` };
});

// 외부 일정 기여 처리 (DATABASE_DESIGN.md 기준)
export const contributeToStudentTimetable = onCall(async (request) => {
  const { shareToken, contributions, contributor } = request.data;

  // 공유 링크 유효성 확인
  // ... 구현

  // schedule_contributions 컬렉션에 기여 데이터 저장
  // ... 구현

  return { success: true };
});

// 기여 데이터 승인/거부 처리
export const processStudentTimetableContribution = onCall(async (request) => {
  if (!request.auth) {
    throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
  }

  const userId = request.auth.uid;
  const { contributionId, action } = request.data; // 'approve' | 'reject'

  // 기여 데이터 조회 및 처리
  // ... 구현

  return { success: true };
});

// 유틸리티 함수들
function generateUniqueToken(): string {
  return Math.random().toString(36).substring(2) + Date.now().toString(36);
}

function parseTime(timeString: string): number {
  const [hours, minutes] = timeString.split(':').map(Number);
  return hours * 60 + minutes;
}
```

### 2. 학생 관리 함수 확장

`functions/src/modules/personal/studentManagement.ts`에 추가:

```typescript
// 학생 + 시간표 정보 통합 조회
export const getStudentsWithTimetables = onCall(async (request) => {
  if (!request.auth) {
    throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
  }

  const userId = request.auth.uid;

  // 모든 학생 조회
  const studentsSnapshot = await db
    .collection(`users/${userId}/students`)
    .where("isActive", "==", true)
    .orderBy("name")
    .get();

  const studentsWithTimetables = [];

  for (const studentDoc of studentsSnapshot.docs) {
    const studentData = { id: studentDoc.id, ...studentDoc.data() };

    // 해당 학생의 활성 시간표 조회
    const timetableSnapshot = await db
      .collection(`users/${userId}/student_timetables`)
      .where("studentId", "==", studentDoc.id)
      .where("isActive", "==", true)
      .limit(1)
      .get();

    // 시간표 개수 조회
    const timetableCountSnapshot = await db
      .collection(`users/${userId}/student_timetables`)
      .where("studentId", "==", studentDoc.id)
      .get();

    studentsWithTimetables.push({
      ...studentData,
      activeTimetable: timetableSnapshot.empty ? null :
        { id: timetableSnapshot.docs[0].id, ...timetableSnapshot.docs[0].data() },
      timetableCount: timetableCountSnapshot.size
    });
  }

  return studentsWithTimetables;
});

export const getStudentWithTimetable = onCall(async (request) => {
  if (!request.auth) {
    throw new HttpsError("unauthenticated", "Google 인증이 필요합니다.");
  }

  const userId = request.auth.uid;
  const { studentId } = request.data;

  // 학생 정보 조회
  const studentDoc = await db.doc(`users/${userId}/students/${studentId}`).get();
  if (!studentDoc.exists) {
    throw new HttpsError("not-found", "학생을 찾을 수 없습니다.");
  }

  const studentData = { id: studentDoc.id, ...studentDoc.data() };

  // 활성 시간표 조회
  const timetableSnapshot = await db
    .collection(`users/${userId}/student_timetables`)
    .where("studentId", "==", studentId)
    .where("isActive", "==", true)
    .limit(1)
    .get();

  // 시간표 개수 조회
  const timetableCountSnapshot = await db
    .collection(`users/${userId}/student_timetables`)
    .where("studentId", "==", studentId)
    .get();

  return {
    ...studentData,
    activeTimetable: timetableSnapshot.empty ? null :
      { id: timetableSnapshot.docs[0].id, ...timetableSnapshot.docs[0].data() },
    timetableCount: timetableCountSnapshot.size
  };
});
```

### 3. functions/src/index.ts 업데이트

```typescript
// 기존 exports...

// 학생별 시간표 관리 (신규)
export {
  createStudentTimetable,
  getStudentTimetables,
  updateStudentTimetable,
  deleteStudentTimetable,
  setActiveStudentTimetable,
  autoFillStudentTimetable,
  createStudentTimetableShareLink,
  contributeToStudentTimetable,
  processStudentTimetableContribution,
} from "./modules/personal/studentTimetableManagement";

// 확장된 학생 관리
export {
  getStudentsWithTimetables,
  getStudentWithTimetable,
} from "./modules/personal/studentManagement";
```

## 🎨 프론트엔드 구현

### 1. 통합 타입 정의

`frontend/src/types/student.ts` 업데이트:

```typescript
// 기존 Student 인터페이스 확장
export interface StudentWithTimetable extends Student {
  activeTimetable?: StudentTimetableData;
  timetableCount: number;
}

// 학생별 시간표 데이터 (DATABASE_DESIGN.md 기준)
export interface StudentTimetableData {
  id: string;
  studentId: string;
  studentName: string;
  name: string;
  description?: string;

  // 1차 레이어: 등원/하원 기본 틀
  basicSchedule: {
    arrivalTime: string;
    departureTime: string;
    daysOfWeek: DayOfWeek[];
    timeSlotInterval: number;
  };

  // 2차 레이어: 구체적인 일정
  detailedSchedule: {
    [dayOfWeek: string]: {
      timeSlots: TimeSlot[];
    };
  };

  // 공유 기능
  isShared: boolean;
  shareToken?: string;
  shareSettings: {
    allowEdit: boolean;
    allowView: boolean;
    expiresAt?: Date;
  };

  // 자동 채우기 설정
  autoFillSettings: {
    enabled: boolean;
    defaultSubject: string;
    fillEmptySlots: boolean;
  };

  isActive: boolean;
  isDefault: boolean;
  createdAt: Date;
  updatedAt: Date;
  userId: string;
}

export interface TimeSlot {
  startTime: string;
  endTime: string;
  subject: string;
  type: 'class' | 'self_study';
  isAutoGenerated: boolean;
  color?: string;
  teacher?: string;
  location?: string;
  notes?: string;
}

export type DayOfWeek = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

// 요청 타입들
export interface CreateStudentTimetableRequest {
  studentId: string;
  name: string;
  basicSchedule: {
    arrivalTime: string;
    departureTime: string;
    daysOfWeek: DayOfWeek[];
    timeSlotInterval: number;
  };
  autoFillSettings?: {
    enabled: boolean;
    defaultSubject: string;
    fillEmptySlots: boolean;
  };
}

export interface UpdateStudentTimetableRequest {
  name?: string;
  description?: string;
  basicSchedule?: any;
  detailedSchedule?: any;
  shareSettings?: any;
  autoFillSettings?: any;
}

export interface ShareTimetableRequest {
  allowEdit: boolean;
  allowView: boolean;
  expiresAt?: Date;
}
```

### 2. 백엔드 서비스 통합

`frontend/src/services/backendService.ts` 확장:

```typescript
// 기존 imports...

// 학생별 시간표 관리 서비스
export const studentTimetableService = {
  // 학생 + 시간표 통합 조회
  getStudentsWithTimetables: async (): Promise<StudentWithTimetable[]> => {
    const getStudentsWithTimetablesFunc = httpsCallable(functions, 'getStudentsWithTimetables');
    const result = await getStudentsWithTimetablesFunc();
    return result.data as StudentWithTimetable[];
  },

  getStudentWithTimetable: async (studentId: string): Promise<StudentWithTimetable> => {
    const getStudentWithTimetableFunc = httpsCallable(functions, 'getStudentWithTimetable');
    const result = await getStudentWithTimetableFunc({ studentId });
    return result.data as StudentWithTimetable;
  },

  // 시간표 CRUD
  createStudentTimetable: async (request: CreateStudentTimetableRequest): Promise<StudentTimetableData> => {
    const createFunc = httpsCallable(functions, 'createStudentTimetable');
    const result = await createFunc(request);
    return result.data as StudentTimetableData;
  },

  getStudentTimetables: async (studentId: string): Promise<StudentTimetableData[]> => {
    const getFunc = httpsCallable(functions, 'getStudentTimetables');
    const result = await getFunc({ studentId });
    return result.data as StudentTimetableData[];
  },

  updateStudentTimetable: async (
    timetableId: string,
    updates: UpdateStudentTimetableRequest
  ): Promise<void> => {
    const updateFunc = httpsCallable(functions, 'updateStudentTimetable');
    await updateFunc({ timetableId, updates });
  },

  deleteStudentTimetable: async (timetableId: string): Promise<void> => {
    const deleteFunc = httpsCallable(functions, 'deleteStudentTimetable');
    await deleteFunc({ timetableId });
  },

  // 고급 기능
  autoFillStudentTimetable: async (timetableId: string): Promise<StudentTimetableData> => {
    const autoFillFunc = httpsCallable(functions, 'autoFillStudentTimetable');
    const result = await autoFillFunc({ timetableId });
    return result.data as StudentTimetableData;
  },

  createShareLink: async (timetableId: string, settings: ShareTimetableRequest): Promise<{shareToken: string, shareUrl: string}> => {
    const shareFunc = httpsCallable(functions, 'createStudentTimetableShareLink');
    const result = await shareFunc({ timetableId, shareSettings: settings });
    return result.data;
  },
};
```

### 3. 통합 TimeTable.tsx 컴포넌트

```typescript
// frontend/src/pages/TimeTable/TimeTable.tsx

import React, { useState, useEffect } from 'react';
import './TimeTable.css';
import { StudentWithTimetable, StudentTimetableData } from '../../types/student';
import { studentTimetableService } from '../../services/backendService';
import StudentListPanel from './components/StudentListPanel';
import StudentTimetablePanel from './components/StudentTimetablePanel';
import LoadingSpinner from '../../components/common/LoadingSpinner';
import ErrorMessage from '../../components/common/ErrorMessage';

const TimeTable: React.FC = () => {
  // 상태 관리
  const [students, setStudents] = useState<StudentWithTimetable[]>([]);
  const [selectedStudent, setSelectedStudent] = useState<StudentWithTimetable | null>(null);
  const [selectedTimetable, setSelectedTimetable] = useState<StudentTimetableData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // 초기 데이터 로딩
  useEffect(() => {
    loadStudentsWithTimetables();
  }, []);

  const loadStudentsWithTimetables = async () => {
    try {
      setLoading(true);
      setError(null);

      const studentsData = await studentTimetableService.getStudentsWithTimetables();
      setStudents(studentsData);

      // 첫 번째 학생 자동 선택
      if (studentsData.length > 0) {
        handleStudentSelect(studentsData[0]);
      }
    } catch (err) {
      setError('학생 목록을 불러오는데 실패했습니다.');
      console.error('Error loading students:', err);
    } finally {
      setLoading(false);
    }
  };

  // 학생 선택 처리
  const handleStudentSelect = async (student: StudentWithTimetable) => {
    try {
      setSelectedStudent(student);
      setSelectedTimetable(student.activeTimetable || null);

      // 상세 시간표 정보 로딩 (필요한 경우)
      if (student.activeTimetable) {
        // 이미 기본 정보가 있으므로 추가 로딩은 선택적
      }
    } catch (err) {
      setError('학생 정보를 불러오는데 실패했습니다.');
      console.error('Error selecting student:', err);
    }
  };

  // 새 학생 추가
  const handleStudentCreate = () => {
    // 학생 추가 모달 또는 페이지로 이동
    console.log('새 학생 추가');
  };

  // 시간표 업데이트
  const handleTimetableUpdate = async (updatedTimetable: StudentTimetableData) => {
    try {
      setSelectedTimetable(updatedTimetable);

      // 학생 목록도 업데이트
      setStudents(prevStudents =>
        prevStudents.map(student =>
          student.id === selectedStudent?.id
            ? { ...student, activeTimetable: updatedTimetable }
            : student
        )
      );
    } catch (err) {
      setError('시간표 업데이트에 실패했습니다.');
      console.error('Error updating timetable:', err);
    }
  };

  // 새 시간표 생성
  const handleTimetableCreate = async () => {
    if (!selectedStudent) return;

    try {
      // 시간표 생성 로직
      console.log('새 시간표 생성');
    } catch (err) {
      setError('시간표 생성에 실패했습니다.');
      console.error('Error creating timetable:', err);
    }
  };

  if (loading) {
    return <LoadingSpinner />;
  }

  return (
    <div className="timetable-page">
      {error && <ErrorMessage message={error} onClose={() => setError(null)} />}

      {/* 왼쪽: 학생 목록 패널 */}
      <div className="student-list-section">
        <StudentListPanel
          students={students}
          selectedStudent={selectedStudent}
          onStudentSelect={handleStudentSelect}
          onStudentCreate={handleStudentCreate}
          onRefresh={loadStudentsWithTimetables}
        />
      </div>

      {/* 오른쪽: 시간표 패널 */}
      <div className="timetable-section">
        {selectedStudent ? (
          <StudentTimetablePanel
            student={selectedStudent}
            timetable={selectedTimetable}
            onTimetableUpdate={handleTimetableUpdate}
            onTimetableCreate={handleTimetableCreate}
          />
        ) : (
          <div className="empty-timetable-state">
            <h3>학생을 선택해주세요</h3>
            <p>왼쪽에서 학생을 선택하면 해당 학생의 시간표를 확인할 수 있습니다.</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default TimeTable;
```

### 4. 하위 컴포넌트 구현

#### A. StudentListPanel 컴포넌트

```typescript
// frontend/src/pages/TimeTable/components/StudentListPanel.tsx

import React, { useState } from 'react';
import { StudentWithTimetable } from '../../../types/student';
import './StudentListPanel.css';

interface StudentListPanelProps {
  students: StudentWithTimetable[];
  selectedStudent: StudentWithTimetable | null;
  onStudentSelect: (student: StudentWithTimetable) => void;
  onStudentCreate: () => void;
  onRefresh: () => void;
}

const StudentListPanel: React.FC<StudentListPanelProps> = ({
  students,
  selectedStudent,
  onStudentSelect,
  onStudentCreate,
  onRefresh
}) => {
  const [searchTerm, setSearchTerm] = useState('');

  // 학생 검색 필터링
  const filteredStudents = students.filter(student =>
    student.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    student.grade.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div className="student-list-panel">
      {/* 헤더 */}
      <div className="panel-header">
        <h2>학생 목록</h2>
        <div className="header-actions">
          <button
            className="btn-refresh"
            onClick={onRefresh}
            title="새로고침"
          >
            🔄
          </button>
          <button
            className="btn-add-student"
            onClick={onStudentCreate}
          >
            + 학생 추가
          </button>
        </div>
      </div>

      {/* 검색 */}
      <div className="search-section">
        <input
          type="text"
          placeholder="학생 이름 또는 학년으로 검색..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="search-input"
        />
      </div>

      {/* 학생 목록 */}
      <div className="student-list">
        {filteredStudents.length === 0 ? (
          <div className="empty-state">
            <p>등록된 학생이 없습니다.</p>
            <button onClick={onStudentCreate} className="btn-add-first">
              첫 번째 학생 추가하기
            </button>
          </div>
        ) : (
          filteredStudents.map(student => (
            <div
              key={student.id}
              className={`student-item ${selectedStudent?.id === student.id ? 'selected' : ''}`}
              onClick={() => onStudentSelect(student)}
            >
              <div className="student-info">
                <h3 className="student-name">{student.name}</h3>
                <p className="student-grade">{student.grade}</p>
                {student.activeTimetable ? (
                  <p className="student-timetable">
                    📅 {student.activeTimetable.name}
                  </p>
                ) : (
                  <p className="no-timetable">시간표 없음</p>
                )}
              </div>
              <div className="student-meta">
                <span className="timetable-count">
                  {student.timetableCount}개 시간표
                </span>
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
};

export default StudentListPanel;
```

#### B. StudentTimetablePanel 컴포넌트

```typescript
// frontend/src/pages/TimeTable/components/StudentTimetablePanel.tsx

import React, { useState } from 'react';
import { StudentWithTimetable, StudentTimetableData } from '../../../types/student';
import TimetableHeader from './TimetableHeader';
import BasicSchedulePanel from './BasicSchedulePanel';
import TimetableGrid from './TimetableGrid';
import SharePanel from './SharePanel';
import './StudentTimetablePanel.css';

interface StudentTimetablePanelProps {
  student: StudentWithTimetable;
  timetable: StudentTimetableData | null;
  onTimetableUpdate: (timetable: StudentTimetableData) => void;
  onTimetableCreate: () => void;
}

const StudentTimetablePanel: React.FC<StudentTimetablePanelProps> = ({
  student,
  timetable,
  onTimetableUpdate,
  onTimetableCreate
}) => {
  const [showSharePanel, setShowSharePanel] = useState(false);
  const [showBasicSettings, setShowBasicSettings] = useState(false);

  if (!timetable) {
    return (
      <div className="no-timetable-state">
        <div className="student-info">
          <h2>{student.name}의 시간표</h2>
          <p className="student-details">{student.grade} | {student.email}</p>
        </div>
        <div className="empty-content">
          <h3>시간표가 없습니다</h3>
          <p>이 학생을 위한 첫 번째 시간표를 만들어보세요.</p>
          <button onClick={onTimetableCreate} className="btn-create-timetable">
            시간표 만들기
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="student-timetable-panel">
      {/* 헤더 */}
      <TimetableHeader
        student={student}
        timetable={timetable}
        onShowShare={() => setShowSharePanel(true)}
        onShowBasicSettings={() => setShowBasicSettings(true)}
        onTimetableUpdate={onTimetableUpdate}
      />

      {/* 1차 레이어: 기본 스케줄 설정 (토글 가능) */}
      {showBasicSettings && (
        <BasicSchedulePanel
          basicSchedule={timetable.basicSchedule}
          autoFillSettings={timetable.autoFillSettings}
          onUpdate={(updates) => {
            // 기본 스케줄 업데이트
            onTimetableUpdate({
              ...timetable,
              ...updates
            });
          }}
          onClose={() => setShowBasicSettings(false)}
        />
      )}

      {/* 2차 레이어: 상세 시간표 그리드 */}
      <TimetableGrid
        timetable={timetable}
        onTimetableUpdate={onTimetableUpdate}
      />

      {/* 공유 패널 (모달) */}
      {showSharePanel && (
        <SharePanel
          timetable={timetable}
          onClose={() => setShowSharePanel(false)}
          onUpdate={onTimetableUpdate}
        />
      )}
    </div>
  );
};

export default StudentTimetablePanel;
```

#### C. TimetableGrid 컴포넌트 (고급 2레이어 구조)

```typescript
// frontend/src/pages/TimeTable/components/TimetableGrid.tsx

import React, { useState } from 'react';
import { StudentTimetableData, TimeSlot, DayOfWeek } from '../../../types/student';
import { studentTimetableService } from '../../../services/backendService';
import TimeSlotEditModal from './TimeSlotEditModal';
import './TimetableGrid.css';

interface TimetableGridProps {
  timetable: StudentTimetableData;
  onTimetableUpdate: (timetable: StudentTimetableData) => void;
}

const TimetableGrid: React.FC<TimetableGridProps> = ({
  timetable,
  onTimetableUpdate
}) => {
  const [editingSlot, setEditingSlot] = useState<{
    day: string;
    slot: TimeSlot;
    index: number;
  } | null>(null);
  const [isAutoFilling, setIsAutoFilling] = useState(false);

  const daysOfWeek: DayOfWeek[] = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
  const dayNames = {
    monday: '월',
    tuesday: '화',
    wednesday: '수',
    thursday: '목',
    friday: '금',
    saturday: '토',
    sunday: '일'
  };

  // 시간 슬롯 생성 (등원 시간부터 하원 시간까지)
  const generateTimeSlots = () => {
    const { arrivalTime, departureTime, timeSlotInterval } = timetable.basicSchedule;
    const slots = [];

    const startMinutes = timeToMinutes(arrivalTime);
    const endMinutes = timeToMinutes(departureTime);

    for (let minutes = startMinutes; minutes < endMinutes; minutes += timeSlotInterval) {
      slots.push({
        startTime: minutesToTime(minutes),
        endTime: minutesToTime(minutes + timeSlotInterval)
      });
    }

    return slots;
  };

  // 자동 자습시간 채우기
  const handleAutoFill = async () => {
    try {
      setIsAutoFilling(true);
      const updatedTimetable = await studentTimetableService.autoFillStudentTimetable(timetable.id);
      onTimetableUpdate(updatedTimetable);
    } catch (error) {
      console.error('자동 채우기 실패:', error);
    } finally {
      setIsAutoFilling(false);
    }
  };

  // 시간 슬롯 클릭 처리
  const handleSlotClick = (day: string, timeSlot: { startTime: string; endTime: string }) => {
    // 해당 시간대에 기존 일정이 있는지 확인
    const daySchedule = timetable.detailedSchedule[day];
    const existingSlotIndex = daySchedule?.timeSlots.findIndex(slot =>
      slot.startTime === timeSlot.startTime && slot.endTime === timeSlot.endTime
    );

    if (existingSlotIndex !== undefined && existingSlotIndex >= 0) {
      // 기존 일정 편집
      setEditingSlot({
        day,
        slot: daySchedule.timeSlots[existingSlotIndex],
        index: existingSlotIndex
      });
    } else {
      // 새 일정 추가
      setEditingSlot({
        day,
        slot: {
          startTime: timeSlot.startTime,
          endTime: timeSlot.endTime,
          subject: '',
          type: 'class',
          isAutoGenerated: false,
          color: '#4CAF50'
        },
        index: -1 // 새 항목
      });
    }
  };

  // 시간표 그리드 렌더링
  const timeSlots = generateTimeSlots();
  const activeDays = timetable.basicSchedule.daysOfWeek;

  return (
    <div className="timetable-grid-container">
      {/* 도구 모음 */}
      <div className="timetable-toolbar">
        <div className="toolbar-left">
          <h3>{timetable.name}</h3>
          <span className="time-range">
            {timetable.basicSchedule.arrivalTime} - {timetable.basicSchedule.departureTime}
          </span>
        </div>
        <div className="toolbar-right">
          <button
            onClick={handleAutoFill}
            disabled={isAutoFilling}
            className="btn-auto-fill"
          >
            {isAutoFilling ? '채우는 중...' : '🔄 자동 자습시간 채우기'}
          </button>
        </div>
      </div>

      {/* 시간표 그리드 */}
      <div className="timetable-grid">
        {/* 헤더: 요일 */}
        <div className="grid-header">
          <div className="time-column-header">시간</div>
          {activeDays.map(day => (
            <div key={day} className="day-header">
              {dayNames[day]}
            </div>
          ))}
        </div>

        {/* 시간 슬롯들 */}
        <div className="grid-body">
          {timeSlots.map((timeSlot, timeIndex) => (
            <div key={timeIndex} className="time-row">
              {/* 시간 컬럼 */}
              <div className="time-cell">
                <span className="time-label">
                  {timeSlot.startTime}
                </span>
              </div>

              {/* 각 요일별 셀 */}
              {activeDays.map(day => {
                const daySchedule = timetable.detailedSchedule[day];
                const existingSlot = daySchedule?.timeSlots.find(slot =>
                  slot.startTime === timeSlot.startTime && slot.endTime === timeSlot.endTime
                );

                return (
                  <div
                    key={`${day}-${timeIndex}`}
                    className={`schedule-cell ${existingSlot ? 'has-content' : 'empty'}`}
                    onClick={() => handleSlotClick(day, timeSlot)}
                  >
                    {existingSlot ? (
                      <div
                        className={`slot-content ${existingSlot.type}`}
                        style={{ backgroundColor: existingSlot.color }}
                      >
                        <div className="slot-subject">{existingSlot.subject}</div>
                        {existingSlot.teacher && (
                          <div className="slot-teacher">{existingSlot.teacher}</div>
                        )}
                        {existingSlot.isAutoGenerated && (
                          <div className="auto-generated-badge">자동</div>
                        )}
                      </div>
                    ) : (
                      <div className="empty-slot">
                        <span>+</span>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          ))}
        </div>
      </div>

      {/* 시간 슬롯 편집 모달 */}
      {editingSlot && (
        <TimeSlotEditModal
          day={editingSlot.day}
          timeSlot={editingSlot.slot}
          isNew={editingSlot.index === -1}
          onSave={async (updatedSlot) => {
            // 시간표 업데이트 로직
            const updatedSchedule = { ...timetable.detailedSchedule };

            if (!updatedSchedule[editingSlot.day]) {
              updatedSchedule[editingSlot.day] = { timeSlots: [] };
            }

            if (editingSlot.index === -1) {
              // 새 항목 추가
              updatedSchedule[editingSlot.day].timeSlots.push(updatedSlot);
            } else {
              // 기존 항목 수정
              updatedSchedule[editingSlot.day].timeSlots[editingSlot.index] = updatedSlot;
            }

            const updatedTimetable = {
              ...timetable,
              detailedSchedule: updatedSchedule
            };

            await studentTimetableService.updateStudentTimetable(timetable.id, {
              detailedSchedule: updatedSchedule
            });

            onTimetableUpdate(updatedTimetable);
            setEditingSlot(null);
          }}
          onDelete={async () => {
            if (editingSlot.index >= 0) {
              const updatedSchedule = { ...timetable.detailedSchedule };
              updatedSchedule[editingSlot.day].timeSlots.splice(editingSlot.index, 1);

              const updatedTimetable = {
                ...timetable,
                detailedSchedule: updatedSchedule
              };

              await studentTimetableService.updateStudentTimetable(timetable.id, {
                detailedSchedule: updatedSchedule
              });

              onTimetableUpdate(updatedTimetable);
            }
            setEditingSlot(null);
          }}
          onClose={() => setEditingSlot(null)}
        />
      )}
    </div>
  );
};

// 유틸리티 함수들
function timeToMinutes(time: string): number {
  const [hours, minutes] = time.split(':').map(Number);
  return hours * 60 + minutes;
}

function minutesToTime(minutes: number): string {
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
}

export default TimetableGrid;
```

### 5. CSS 스타일링

`frontend/src/pages/TimeTable/TimeTable.css`:

```css
/* 메인 레이아웃 */
.timetable-page {
  display: flex;
  height: 100vh;
  background-color: #f5f5f5;
  gap: 16px;
  padding: 16px;
}

/* 왼쪽 학생 목록 섹션 */
.student-list-section {
  width: 320px;
  min-width: 320px;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

/* 오른쪽 시간표 섹션 */
.timetable-section {
  flex: 1;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  overflow: auto;
}

/* 빈 상태 */
.empty-timetable-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 40px;
  text-align: center;
  color: #666;
}

.empty-timetable-state h3 {
  margin-bottom: 16px;
  color: #333;
}

.empty-timetable-state p {
  margin-bottom: 24px;
  font-size: 14px;
}

/* 학생 목록 패널 스타일 */
.student-list-panel {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.panel-header {
  display: flex;
  justify-content: between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #e0e0e0;
}

.panel-header h2 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.header-actions {
  display: flex;
  gap: 8px;
}

.btn-refresh {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
}

.btn-refresh:hover {
  background-color: #f0f0f0;
}

.btn-add-student {
  background-color: #2196F3;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
}

.btn-add-student:hover {
  background-color: #1976D2;
}

/* 검색 섹션 */
.search-section {
  padding: 16px;
  border-bottom: 1px solid #e0e0e0;
}

.search-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 14px;
}

.search-input:focus {
  outline: none;
  border-color: #2196F3;
}

/* 학생 목록 */
.student-list {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.student-item {
  padding: 12px;
  margin-bottom: 8px;
  border-radius: 6px;
  border: 1px solid #e0e0e0;
  cursor: pointer;
  transition: all 0.2s ease;
}

.student-item:hover {
  border-color: #2196F3;
  box-shadow: 0 2px 4px rgba(33, 150, 243, 0.1);
}

.student-item.selected {
  border-color: #2196F3;
  background-color: #E3F2FD;
}

.student-info h3 {
  margin: 0 0 4px 0;
  font-size: 16px;
  font-weight: 600;
}

.student-grade {
  margin: 0 0 8px 0;
  font-size: 14px;
  color: #666;
}

.student-timetable {
  margin: 0;
  font-size: 12px;
  color: #4CAF50;
}

.no-timetable {
  margin: 0;
  font-size: 12px;
  color: #999;
}

.student-meta {
  margin-top: 8px;
  text-align: right;
}

.timetable-count {
  font-size: 11px;
  color: #999;
}

/* 시간표 그리드 스타일 */
.timetable-grid-container {
  padding: 16px;
}

.timetable-toolbar {
  display: flex;
  justify-content: between;
  align-items: center;
  margin-bottom: 16px;
  padding: 12px;
  background-color: #f8f9fa;
  border-radius: 6px;
}

.toolbar-left h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
}

.time-range {
  font-size: 14px;
  color: #666;
  margin-left: 8px;
}

.btn-auto-fill {
  background-color: #FF9800;
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

.btn-auto-fill:hover:not(:disabled) {
  background-color: #F57C00;
}

.btn-auto-fill:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* 그리드 레이아웃 */
.timetable-grid {
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  overflow: hidden;
}

.grid-header {
  display: grid;
  grid-template-columns: 80px repeat(auto-fit, minmax(120px, 1fr));
  background-color: #f5f5f5;
  border-bottom: 2px solid #e0e0e0;
}

.time-column-header,
.day-header {
  padding: 12px 8px;
  font-weight: 600;
  text-align: center;
  border-right: 1px solid #e0e0e0;
}

.time-row {
  display: grid;
  grid-template-columns: 80px repeat(auto-fit, minmax(120px, 1fr));
  border-bottom: 1px solid #e0e0e0;
  min-height: 60px;
}

.time-cell {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
  border-right: 1px solid #e0e0e0;
  background-color: #fafafa;
}

.time-label {
  font-size: 12px;
  font-weight: 500;
  color: #666;
}

.schedule-cell {
  border-right: 1px solid #e0e0e0;
  cursor: pointer;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 60px;
}

.schedule-cell:hover {
  background-color: #f0f8ff;
}

.schedule-cell.has-content:hover {
  background-color: transparent;
}

.slot-content {
  width: 100%;
  height: 100%;
  padding: 8px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  border-radius: 4px;
  margin: 2px;
  position: relative;
  color: white;
  font-weight: 500;
}

.slot-content.class {
  background-color: #4CAF50;
}

.slot-content.self_study {
  background-color: #9E9E9E;
}

.slot-subject {
  font-size: 13px;
  font-weight: 600;
  margin-bottom: 2px;
}

.slot-teacher {
  font-size: 11px;
  opacity: 0.9;
}

.auto-generated-badge {
  position: absolute;
  top: 2px;
  right: 2px;
  background-color: rgba(255, 255, 255, 0.8);
  color: #666;
  font-size: 8px;
  padding: 1px 3px;
  border-radius: 2px;
}

.empty-slot {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #ccc;
  font-size: 20px;
  font-weight: 300;
}

.empty-slot:hover {
  color: #2196F3;
}

/* 반응형 디자인 */
@media (max-width: 768px) {
  .timetable-page {
    flex-direction: column;
    height: auto;
    min-height: 100vh;
  }

  .student-list-section {
    width: 100%;
    height: 200px;
  }

  .timetable-section {
    min-height: 500px;
  }

  .grid-header,
  .time-row {
    grid-template-columns: 60px repeat(auto-fit, minmax(80px, 1fr));
  }

  .slot-content {
    padding: 4px;
  }

  .slot-subject {
    font-size: 11px;
  }

  .slot-teacher {
    font-size: 9px;
  }
}
```

## 🔄 데이터 플로우

### 1. 초기 로딩 순서
```
1. TimeTable.tsx 마운트 → useEffect 실행
2. getStudentsWithTimetables() 호출
3. 각 학생별 활성 시간표 정보 함께 로드
4. 첫 번째 학생 자동 선택
5. 선택된 학생의 시간표 표시
```

### 2. 학생 선택 플로우
```
1. StudentListPanel에서 학생 클릭
2. handleStudentSelect() 호출
3. 선택된 학생의 활성 시간표 설정
4. StudentTimetablePanel 리렌더링
5. TimetableGrid에 시간표 데이터 표시
```

### 3. 시간표 편집 플로우
```
1. TimetableGrid에서 시간 슬롯 클릭
2. TimeSlotEditModal 열기
3. 사용자가 편집 후 저장
4. updateStudentTimetable() 호출
5. 로컬 상태 업데이트
6. UI 리렌더링
```

### 4. 자동 자습시간 채우기 플로우
```
1. "자동 자습시간 채우기" 버튼 클릭
2. autoFillStudentTimetable() 호출
3. 백엔드에서 빈 시간대 계산
4. 자습 시간 자동 생성 (isAutoGenerated: true)
5. 업데이트된 시간표 반환
6. UI 업데이트
```

### 5. 시간표 공유 플로우
```
1. "공유" 버튼 클릭 → SharePanel 열기
2. 공유 설정 입력 후 생성
3. createStudentTimetableShareLink() 호출
4. 고유 shareToken 생성
5. shared_schedules 컬렉션에 공유 정보 저장
6. 공유 링크 URL 반환
```

## 🚀 구현 우선순위

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "통합된 시간표 페이지 구현 계획서 작성", "status": "completed", "activeForm": "통합된 시간표 페이지 구현 계획서 작성 완료"}, {"content": "Phase 1 구현 계획 정리", "status": "in_progress", "activeForm": "Phase 1 구현 계획 정리 중"}]